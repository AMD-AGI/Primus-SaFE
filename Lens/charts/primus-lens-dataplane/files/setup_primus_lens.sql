-- Primus Lens Database Initialization Script
-- This script creates the necessary database schema for Primus Lens
-- Generated by merging base schema and all migrations

-- Create database if not exists
create database "primus-lens";

-- Grant privileges to user 'primus-lens'
GRANT CONNECT ON DATABASE "primus-lens" TO "primus-lens";
GRANT CREATE, TEMPORARY ON DATABASE "primus-lens" TO "primus-lens";
GRANT USAGE ON SCHEMA public TO "primus-lens";
GRANT CREATE ON SCHEMA public TO "primus-lens";

ALTER SYSTEM SET max_connections = 500;

-- Connect to the database
\c "primus-lens"

-- Grant privileges on the database
GRANT CONNECT ON DATABASE "primus-lens" TO "primus-lens";
GRANT CREATE, TEMPORARY ON DATABASE "primus-lens" TO "primus-lens";
GRANT USAGE ON SCHEMA public TO "primus-lens";
GRANT CREATE ON SCHEMA public TO "primus-lens";

-- ============================================================================
-- Section 1: Core Tables (Base Schema)
-- ============================================================================

create table node
(
    id                 serial constraint node_pk primary key,
    name               varchar(65),
    address            varchar(32),
    gpu_name           varchar(128),
    gpu_allocation     integer,
    gpu_count          integer,
    gpu_utilization    double precision,
    status             varchar(64),
    created_at         timestamp with time zone,
    updated_at         timestamp with time zone,
    cpu                varchar(64),
    cpu_count          integer,
    memory             varchar(64),
    k8s_version        varchar(64),
    k8s_status         varchar(64),
    kubelet_version    varchar(64),
    containerd_version varchar(64),
    os                 varchar(64),
    driver_version     varchar(64),
    taints             jsonb
);

alter table node owner to "primus-lens";

create table gpu_device
(
    id               serial constraint gpu_device_pk primary key,
    node_id          integer,
    gpu_id           integer,
    gpu_model        varchar(64),
    memory           integer,
    utilization      double precision,
    temperature      double precision,
    power            double precision,
    serial           varchar(128),
    rdma_device_name varchar(64),
    rdma_guid        varchar(64),
    rdma_lid         varchar(64),
    created_at       timestamp with time zone,
    updated_at       timestamp with time zone,
    numa_node        integer,
    numa_affinity    integer
);

alter table gpu_device owner to "primus-lens";

create unique index idx_gpu_device_node_gpu_unique on gpu_device (node_id, gpu_id);
create index idx_gpu_device_node_id on gpu_device (node_id);

create table gpu_pods
(
    id            serial constraint gpu_pods_pk primary key,
    namespace     varchar(64),
    name          varchar(64),
    node_name     varchar(64),
    uid           varchar(64),
    gpu_allocated integer,
    phase         varchar(64),
    deleted       boolean,
    created_at    timestamp with time zone,
    updated_at    timestamp with time zone,
    owner_uid     varchar(64),
    running       boolean,
    ip            varchar(32)
);

alter table gpu_pods owner to "primus-lens";

create table gpu_pods_event
(
    id            serial constraint gpu_pods_event_pk primary key,
    pod_uuid      varchar(64),
    pod_phase     varchar(64),
    event_type    varchar(64),
    created_at    timestamp with time zone,
    restart_count integer
);

alter table gpu_pods_event owner to "primus-lens";

create table gpu_workload
(
    id            serial constraint gpu_workload_pk primary key,
    group_version varchar(128),
    kind          varchar(64),
    namespace     varchar(64),
    name          varchar(64),
    uid           varchar(128),
    parent_uid    varchar(128),
    gpu_request   integer,
    created_at    timestamp with time zone,
    updated_at    timestamp with time zone,
    deleted_at    timestamp with time zone,
    end_at        timestamp with time zone,
    status        varchar(64),
    source        varchar(64),
    labels        jsonb,
    annotations   jsonb
);

alter table gpu_workload owner to "primus-lens";

create table pod_snapshot
(
    id               serial constraint pod_snapshot_pk primary key,
    pod_uid          varchar(64),
    pod_name         varchar(64),
    namespace        varchar(64),
    spec             jsonb,
    metadata         jsonb,
    status           jsonb,
    created_at       timestamp with time zone,
    resource_version integer
);

alter table pod_snapshot owner to "primus-lens";

create index pod_snapshot_pod_uid_resource_version_index
    on pod_snapshot (pod_uid asc, resource_version desc);

create table gpu_workload_snapshot
(
    id               serial constraint gpu_workload_snapshot_pk primary key,
    uid              varchar(64),
    group_version    varchar(128),
    kind             varchar(64),
    name             varchar(64),
    namespace        varchar(64),
    metadata         jsonb,
    detail           jsonb,
    resource_version integer,
    created_at       timestamp with time zone
);

alter table gpu_workload_snapshot owner to "primus-lens";

create table workload_pod_reference
(
    id           serial,
    workload_uid varchar(64),
    pod_uid      varchar(64),
    created_at   timestamp with time zone
);

alter table workload_pod_reference owner to "primus-lens";

create table fault
(
    id       serial constraint fault_pk primary key,
    code     varchar(64),
    kind     varchar(64),
    name     varchar(64),
    detail   jsonb,
    plugin   varchar(64),
    start_at timestamp with time zone,
    end_at   timestamp with time zone,
    level    integer
);

alter table fault owner to "primus-lens";

create table workload_resource
(
    id               serial constraint workload_resource_pk primary key,
    workload_uid     varchar(64),
    gpu_time_seconds double precision,
    gpu_request      integer,
    gpu_model        varchar(64),
    pod_count        integer,
    updated_at       timestamp with time zone
);

alter table workload_resource owner to "primus-lens";

create table pod_resource
(
    id            serial constraint pod_resource_pk primary key,
    uid           varchar(64),
    gpu_model     varchar(64),
    gpu_allocated integer,
    created_at    timestamp with time zone,
    end_at        timestamp with time zone
);

alter table pod_resource owner to "primus-lens";

create table node_container
(
    id             serial constraint node_container_pk primary key,
    container_id   varchar(128),
    container_name varchar(128),
    pod_uid        varchar(128),
    pod_name       varchar(128),
    pod_namespace  varchar(128),
    status         varchar(128),
    created_at     timestamp with time zone,
    updated_at     timestamp with time zone,
    node_name      varchar(128),
    source         varchar(128)
);

alter table node_container owner to "primus-lens";

create unique index idx_node_container_container_id_unique on node_container (container_id);
create index idx_node_container_pod_uid on node_container (pod_uid);

create table node_container_devices
(
    id            serial constraint node_container_devices_pk primary key,
    container_id  varchar(64),
    device_type   varchar(64),
    device_name   varchar(64),
    device_no     integer,
    device_uuid   varchar(64),
    created_at    timestamp with time zone,
    restart_count integer,
    updated_at    timestamp with time zone
);

alter table node_container_devices owner to "primus-lens";

create table node_container_event
(
    id           serial constraint node_container_event_pk primary key,
    container_id varchar(64),
    event_type   varchar(64),
    created_at   timestamp with time zone
);

alter table node_container_event owner to "primus-lens";

create index node_container_event_container_id_index
    on node_container_event (container_id);

-- Create enum type for data source
DO $$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'training_data_source') THEN
        CREATE TYPE training_data_source AS ENUM ('log', 'wandb', 'tensorflow');
    END IF;
END $$;

create table training_performance
(
    id           serial constraint training_performance_pk primary key,
    pod_uuid     varchar(256),
    performance  jsonb,
    iteration    integer,
    created_at   timestamp with time zone,
    serial       integer,
    workload_uid varchar(256),
    data_source  training_data_source DEFAULT 'log'
);

alter table training_performance owner to "primus-lens";

CREATE INDEX IF NOT EXISTS idx_training_performance_data_source
ON training_performance(data_source);

CREATE INDEX IF NOT EXISTS idx_training_performance_workload_source_iteration
ON training_performance(workload_uid, data_source, iteration DESC);

create table ai_workload_metadata
(
    id           serial constraint ai_workload_metadata_pk primary key,
    workload_uid varchar(256),
    type         varchar(256),
    framework    varchar(256),
    metadata     jsonb,
    created_at   timestamp with time zone,
    image_prefix TEXT
);

alter table ai_workload_metadata owner to "primus-lens";

CREATE INDEX IF NOT EXISTS idx_ai_workload_metadata_metadata_gin 
ON ai_workload_metadata USING GIN (metadata jsonb_path_ops);

CREATE INDEX IF NOT EXISTS idx_ai_workload_metadata_created_at
ON ai_workload_metadata(created_at DESC);

CREATE INDEX IF NOT EXISTS idx_ai_workload_metadata_workload_uid
ON ai_workload_metadata(workload_uid);

CREATE INDEX IF NOT EXISTS idx_ai_workload_metadata_reuse_query
ON ai_workload_metadata(image_prefix, created_at DESC)
WHERE image_prefix IS NOT NULL;

create table workload_event
(
    id                   serial constraint workload_event_pk primary key,
    workload_uid         varchar(256),
    type                 varchar(256),
    run_serial           integer,
    created_at           timestamp with time zone,
    pod_uid              varchar(256),
    nearest_workload_uid varchar(256)
);

alter table workload_event owner to "primus-lens";

create table rdma_device
(
    id         serial constraint rdma_device_pk primary key,
    node_id    integer,
    ifname     varchar(512),
    node_guid  varchar(256),
    if_index   integer,
    fw         varchar(64),
    node_type  varchar(64),
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    deleted_at timestamp with time zone
);

alter table rdma_device owner to "primus-lens";

create table node_device_changelog
(
    id          serial constraint node_device_changelog_pk primary key,
    node_id     integer,
    node_name   varchar(256),
    device_type varchar(32),
    device_name varchar(256),
    device_uuid varchar(256),
    op          varchar(32),
    created_at  timestamp with time zone
);

alter table node_device_changelog owner to "primus-lens";

create table storage
(
    id         serial constraint storage_pk primary key,
    name       varchar(64),
    kind       varchar(64),
    config     jsonb,
    source     varchar(64),
    status     varchar(64),
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    deleted_at timestamp with time zone
);

alter table storage owner to "primus-lens";

-- ============================================================================
-- Section 2: System Configuration Tables
-- ============================================================================

CREATE TABLE IF NOT EXISTS system_config (
    id BIGSERIAL PRIMARY KEY,
    key VARCHAR(255) NOT NULL UNIQUE,
    value JSONB NOT NULL,
    description TEXT,
    category VARCHAR(100),
    is_encrypted BOOLEAN DEFAULT FALSE,
    version INTEGER DEFAULT 1,
    is_readonly BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_by VARCHAR(255),
    updated_by VARCHAR(255)
);

CREATE UNIQUE INDEX IF NOT EXISTS idx_system_config_key ON system_config(key);
CREATE INDEX IF NOT EXISTS idx_system_config_category ON system_config(category);
CREATE INDEX IF NOT EXISTS idx_system_config_updated_at ON system_config(updated_at DESC);
CREATE INDEX IF NOT EXISTS idx_system_config_value ON system_config USING GIN(value);

CREATE TABLE IF NOT EXISTS system_config_history (
    id BIGSERIAL PRIMARY KEY,
    config_id BIGINT NOT NULL,
    key VARCHAR(255) NOT NULL,
    old_value JSONB,
    new_value JSONB NOT NULL,
    version INTEGER NOT NULL,
    change_reason TEXT,
    changed_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    changed_by VARCHAR(255),
    CONSTRAINT fk_system_config_history_config FOREIGN KEY (config_id) REFERENCES system_config(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_system_config_history_config_id ON system_config_history(config_id);
CREATE INDEX IF NOT EXISTS idx_system_config_history_key ON system_config_history(key);
CREATE INDEX IF NOT EXISTS idx_system_config_history_changed_at ON system_config_history(changed_at DESC);

-- ============================================================================
-- Section 3: Generic Cache Table
-- ============================================================================

CREATE TABLE IF NOT EXISTS generic_cache (
    id BIGSERIAL PRIMARY KEY,
    key VARCHAR(255) NOT NULL UNIQUE,
    value JSONB NOT NULL,
    expires_at TIMESTAMP,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE UNIQUE INDEX IF NOT EXISTS idx_generic_cache_key ON generic_cache(key);
CREATE INDEX IF NOT EXISTS idx_generic_cache_expires_at ON generic_cache(expires_at) WHERE expires_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_generic_cache_updated_at ON generic_cache(updated_at DESC);
CREATE INDEX IF NOT EXISTS idx_generic_cache_value ON generic_cache USING GIN(value);

-- ============================================================================
-- Section 4: Namespace Info Table
-- ============================================================================

CREATE TABLE IF NOT EXISTS namespace_info (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL UNIQUE,
    gpu_model VARCHAR(100) NOT NULL,
    gpu_resource INT NOT NULL DEFAULT 0,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE UNIQUE INDEX IF NOT EXISTS idx_namespace_info_name ON namespace_info(name);
CREATE INDEX IF NOT EXISTS idx_namespace_info_gpu_model ON namespace_info(gpu_model);
CREATE INDEX IF NOT EXISTS idx_namespace_info_updated_at ON namespace_info(updated_at DESC);

-- ============================================================================
-- Section 5: Cluster Overview Cache Table
-- ============================================================================

CREATE TABLE IF NOT EXISTS cluster_overview_cache (
    id SERIAL PRIMARY KEY,
    cluster_name VARCHAR(100) NOT NULL,
    total_nodes INT NOT NULL DEFAULT 0,
    healthy_nodes INT NOT NULL DEFAULT 0,
    faulty_nodes INT NOT NULL DEFAULT 0,
    fully_idle_nodes INT NOT NULL DEFAULT 0,
    partially_idle_nodes INT NOT NULL DEFAULT 0,
    busy_nodes INT NOT NULL DEFAULT 0,
    allocation_rate DOUBLE PRECISION NOT NULL DEFAULT 0,
    utilization DOUBLE PRECISION NOT NULL DEFAULT 0,
    storage_total_space DOUBLE PRECISION NOT NULL DEFAULT 0,
    storage_used_space DOUBLE PRECISION NOT NULL DEFAULT 0,
    storage_usage_percentage DOUBLE PRECISION NOT NULL DEFAULT 0,
    storage_total_inodes DOUBLE PRECISION NOT NULL DEFAULT 0,
    storage_used_inodes DOUBLE PRECISION NOT NULL DEFAULT 0,
    storage_inodes_usage_percentage DOUBLE PRECISION NOT NULL DEFAULT 0,
    storage_read_bandwidth DOUBLE PRECISION NOT NULL DEFAULT 0,
    storage_write_bandwidth DOUBLE PRECISION NOT NULL DEFAULT 0,
    rdma_total_tx DOUBLE PRECISION NOT NULL DEFAULT 0,
    rdma_total_rx DOUBLE PRECISION NOT NULL DEFAULT 0,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE UNIQUE INDEX IF NOT EXISTS idx_cluster_overview_cache_cluster_name ON cluster_overview_cache(cluster_name);
CREATE INDEX IF NOT EXISTS idx_cluster_overview_cache_updated_at ON cluster_overview_cache(updated_at DESC);

-- ============================================================================
-- Section 6: Checkpoint Event Table
-- ============================================================================

CREATE TABLE IF NOT EXISTS checkpoint_event (
    id BIGSERIAL PRIMARY KEY,
    workload_uid VARCHAR(255) NOT NULL,
    pod_uuid VARCHAR(255),
    iteration INTEGER NOT NULL,
    checkpoint_path TEXT,
    event_type VARCHAR(50) NOT NULL,
    start_time TIMESTAMP,
    end_time TIMESTAMP,
    duration_ms BIGINT DEFAULT 0,
    size_bytes BIGINT DEFAULT 0,
    is_fast_ckpt BOOLEAN DEFAULT false,
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    serial INTEGER DEFAULT 1,
    status VARCHAR(50) DEFAULT 'in_progress'
);

CREATE INDEX IF NOT EXISTS idx_checkpoint_event_workload_uid ON checkpoint_event(workload_uid);
CREATE INDEX IF NOT EXISTS idx_checkpoint_event_iteration ON checkpoint_event(iteration);
CREATE INDEX IF NOT EXISTS idx_checkpoint_event_type ON checkpoint_event(event_type);
CREATE INDEX IF NOT EXISTS idx_checkpoint_event_status ON checkpoint_event(status);
CREATE INDEX IF NOT EXISTS idx_checkpoint_event_created_at ON checkpoint_event(created_at);
CREATE INDEX IF NOT EXISTS idx_checkpoint_event_workload_iteration ON checkpoint_event(workload_uid, iteration);

-- ============================================================================
-- Section 7: Job Execution History Table
-- ============================================================================

CREATE TABLE IF NOT EXISTS job_execution_history (
    id BIGSERIAL PRIMARY KEY,
    job_name VARCHAR(255) NOT NULL,
    job_type VARCHAR(100) NOT NULL,
    schedule VARCHAR(50),
    status VARCHAR(20) NOT NULL DEFAULT 'running',
    started_at TIMESTAMP NOT NULL,
    ended_at TIMESTAMP,
    duration_seconds DOUBLE PRECISION,
    error_message TEXT,
    error_stack TEXT,
    cluster_name VARCHAR(100),
    hostname VARCHAR(255),
    metadata JSONB,
    execution_stats JSONB,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX IF NOT EXISTS idx_job_execution_history_job_name ON job_execution_history(job_name);
CREATE INDEX IF NOT EXISTS idx_job_execution_history_status ON job_execution_history(status);
CREATE INDEX IF NOT EXISTS idx_job_execution_history_started_at ON job_execution_history(started_at DESC);
CREATE INDEX IF NOT EXISTS idx_job_execution_history_ended_at ON job_execution_history(ended_at DESC);
CREATE INDEX IF NOT EXISTS idx_job_execution_history_job_name_started_at ON job_execution_history(job_name, started_at DESC);
CREATE INDEX IF NOT EXISTS idx_job_execution_history_status_started_at ON job_execution_history(status, started_at DESC);
CREATE INDEX IF NOT EXISTS idx_job_execution_history_duration ON job_execution_history(duration_seconds) WHERE duration_seconds IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_job_execution_history_metadata ON job_execution_history USING GIN(metadata);

-- ============================================================================
-- Section 8: GPU Usage Aggregation Tables
-- ============================================================================

CREATE TABLE IF NOT EXISTS cluster_gpu_hourly_stats (
    id SERIAL PRIMARY KEY,
    cluster_name VARCHAR(100) NOT NULL,
    stat_hour TIMESTAMP NOT NULL,
    total_gpu_capacity INT NOT NULL DEFAULT 0,
    allocated_gpu_count DOUBLE PRECISION NOT NULL DEFAULT 0,
    allocation_rate DOUBLE PRECISION NOT NULL DEFAULT 0,
    avg_utilization DOUBLE PRECISION NOT NULL DEFAULT 0,
    max_utilization DOUBLE PRECISION NOT NULL DEFAULT 0,
    min_utilization DOUBLE PRECISION NOT NULL DEFAULT 0,
    p50_utilization DOUBLE PRECISION NOT NULL DEFAULT 0,
    p95_utilization DOUBLE PRECISION NOT NULL DEFAULT 0,
    sample_count INT NOT NULL DEFAULT 0,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE UNIQUE INDEX IF NOT EXISTS idx_cluster_gpu_hourly_cluster_hour 
    ON cluster_gpu_hourly_stats(cluster_name, stat_hour DESC);
CREATE INDEX IF NOT EXISTS idx_cluster_gpu_hourly_hour 
    ON cluster_gpu_hourly_stats(stat_hour DESC);

CREATE TABLE IF NOT EXISTS namespace_gpu_hourly_stats (
    id SERIAL PRIMARY KEY,
    cluster_name VARCHAR(100) NOT NULL,
    namespace VARCHAR(253) NOT NULL,
    stat_hour TIMESTAMP NOT NULL,
    total_gpu_capacity INT NOT NULL DEFAULT 0,
    allocated_gpu_count DOUBLE PRECISION NOT NULL DEFAULT 0,
    avg_utilization DOUBLE PRECISION NOT NULL DEFAULT 0,
    max_utilization DOUBLE PRECISION NOT NULL DEFAULT 0,
    min_utilization DOUBLE PRECISION NOT NULL DEFAULT 0,
    active_workload_count INT NOT NULL DEFAULT 0,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE UNIQUE INDEX IF NOT EXISTS idx_namespace_gpu_hourly_cluster_ns_hour 
    ON namespace_gpu_hourly_stats(cluster_name, namespace, stat_hour DESC);
CREATE INDEX IF NOT EXISTS idx_namespace_gpu_hourly_cluster_hour 
    ON namespace_gpu_hourly_stats(cluster_name, stat_hour DESC);
CREATE INDEX IF NOT EXISTS idx_namespace_gpu_hourly_namespace 
    ON namespace_gpu_hourly_stats(namespace, stat_hour DESC);

CREATE TABLE IF NOT EXISTS label_gpu_hourly_stats (
    id SERIAL PRIMARY KEY,
    cluster_name VARCHAR(100) NOT NULL,
    dimension_type VARCHAR(20) NOT NULL,
    dimension_key VARCHAR(255) NOT NULL,
    dimension_value TEXT NOT NULL,
    stat_hour TIMESTAMP NOT NULL,
    allocated_gpu_count DOUBLE PRECISION NOT NULL DEFAULT 0,
    avg_utilization DOUBLE PRECISION NOT NULL DEFAULT 0,
    max_utilization DOUBLE PRECISION NOT NULL DEFAULT 0,
    min_utilization DOUBLE PRECISION NOT NULL DEFAULT 0,
    active_workload_count INT NOT NULL DEFAULT 0,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE UNIQUE INDEX IF NOT EXISTS idx_label_gpu_hourly_cluster_type_key_value_hour 
    ON label_gpu_hourly_stats(cluster_name, dimension_type, dimension_key, dimension_value, stat_hour DESC);
CREATE INDEX IF NOT EXISTS idx_label_gpu_hourly_cluster_hour 
    ON label_gpu_hourly_stats(cluster_name, stat_hour DESC);
CREATE INDEX IF NOT EXISTS idx_label_gpu_hourly_type_key 
    ON label_gpu_hourly_stats(dimension_type, dimension_key, stat_hour DESC);

CREATE TABLE IF NOT EXISTS gpu_allocation_snapshots (
    id SERIAL PRIMARY KEY,
    cluster_name VARCHAR(100) NOT NULL,
    snapshot_time TIMESTAMP NOT NULL,
    dimension_type VARCHAR(20) NOT NULL,
    dimension_key VARCHAR(255),
    dimension_value TEXT,
    total_gpu_capacity INT NOT NULL DEFAULT 0,
    allocated_gpu_count INT NOT NULL DEFAULT 0,
    allocation_details JSONB NOT NULL DEFAULT '{}',
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX IF NOT EXISTS idx_gpu_allocation_snapshots_cluster_time 
    ON gpu_allocation_snapshots(cluster_name, snapshot_time DESC);
CREATE INDEX IF NOT EXISTS idx_gpu_allocation_snapshots_time 
    ON gpu_allocation_snapshots(snapshot_time DESC);
CREATE INDEX IF NOT EXISTS idx_gpu_allocation_snapshots_dimension 
    ON gpu_allocation_snapshots(cluster_name, dimension_type, dimension_key, dimension_value, snapshot_time DESC);

-- ============================================================================
-- Section 9: Workload GPU Usage Stats Table
-- ============================================================================

CREATE TABLE IF NOT EXISTS workload_gpu_hourly_stats (
    id SERIAL PRIMARY KEY,
    cluster_name VARCHAR(100) NOT NULL,
    namespace VARCHAR(253) NOT NULL,
    workload_name VARCHAR(253) NOT NULL,
    workload_type VARCHAR(50) NOT NULL,
    stat_hour TIMESTAMP NOT NULL,
    allocated_gpu_count DOUBLE PRECISION NOT NULL DEFAULT 0,
    requested_gpu_count DOUBLE PRECISION NOT NULL DEFAULT 0,
    avg_utilization DOUBLE PRECISION NOT NULL DEFAULT 0,
    max_utilization DOUBLE PRECISION NOT NULL DEFAULT 0,
    min_utilization DOUBLE PRECISION NOT NULL DEFAULT 0,
    p50_utilization DOUBLE PRECISION NOT NULL DEFAULT 0,
    p95_utilization DOUBLE PRECISION NOT NULL DEFAULT 0,
    avg_gpu_memory_used DOUBLE PRECISION NOT NULL DEFAULT 0,
    max_gpu_memory_used DOUBLE PRECISION NOT NULL DEFAULT 0,
    avg_gpu_memory_total DOUBLE PRECISION NOT NULL DEFAULT 0,
    avg_replica_count DOUBLE PRECISION NOT NULL DEFAULT 0,
    max_replica_count INT NOT NULL DEFAULT 0,
    min_replica_count INT NOT NULL DEFAULT 0,
    workload_status VARCHAR(50),
    sample_count INT NOT NULL DEFAULT 0,
    owner_uid VARCHAR(255),
    owner_name VARCHAR(255),
    labels JSONB NOT NULL DEFAULT '{}',
    annotations JSONB NOT NULL DEFAULT '{}',
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE UNIQUE INDEX IF NOT EXISTS idx_workload_gpu_hourly_cluster_ns_wl_hour 
    ON workload_gpu_hourly_stats(cluster_name, namespace, workload_name, stat_hour DESC);
CREATE INDEX IF NOT EXISTS idx_workload_gpu_hourly_cluster_hour 
    ON workload_gpu_hourly_stats(cluster_name, stat_hour DESC);
CREATE INDEX IF NOT EXISTS idx_workload_gpu_hourly_namespace_hour 
    ON workload_gpu_hourly_stats(namespace, stat_hour DESC);
CREATE INDEX IF NOT EXISTS idx_workload_gpu_hourly_workload_hour 
    ON workload_gpu_hourly_stats(workload_name, stat_hour DESC);
CREATE INDEX IF NOT EXISTS idx_workload_gpu_hourly_type_hour 
    ON workload_gpu_hourly_stats(workload_type, stat_hour DESC);
CREATE INDEX IF NOT EXISTS idx_workload_gpu_hourly_owner 
    ON workload_gpu_hourly_stats(owner_uid, stat_hour DESC) WHERE owner_uid IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_workload_gpu_hourly_hour 
    ON workload_gpu_hourly_stats(stat_hour DESC);
CREATE INDEX IF NOT EXISTS idx_workload_gpu_hourly_labels 
    ON workload_gpu_hourly_stats USING GIN(labels);
CREATE INDEX IF NOT EXISTS idx_workload_gpu_hourly_annotations 
    ON workload_gpu_hourly_stats USING GIN(annotations);

-- ============================================================================
-- Section 10: Workload Statistic Table
-- ============================================================================

CREATE TABLE IF NOT EXISTS workload_statistic (
    id SERIAL PRIMARY KEY,
    uid VARCHAR(255) NOT NULL,
    cluster_name VARCHAR(100) NOT NULL,
    namespace VARCHAR(253) NOT NULL,
    workload_name VARCHAR(253) NOT NULL,
    workload_type VARCHAR(50) NOT NULL,
    instant_gpu_utilization DOUBLE PRECISION NOT NULL DEFAULT 0,
    avg_gpu_utilization DOUBLE PRECISION NOT NULL DEFAULT 0,
    p50_gpu_utilization DOUBLE PRECISION NOT NULL DEFAULT 0,
    p90_gpu_utilization DOUBLE PRECISION NOT NULL DEFAULT 0,
    p95_gpu_utilization DOUBLE PRECISION NOT NULL DEFAULT 0,
    max_gpu_utilization DOUBLE PRECISION NOT NULL DEFAULT 0,
    min_gpu_utilization DOUBLE PRECISION NOT NULL DEFAULT 0,
    stat_start_time TIMESTAMP NOT NULL,
    stat_end_time TIMESTAMP NOT NULL,
    sample_count INT NOT NULL DEFAULT 0,
    allocated_gpu_count DOUBLE PRECISION NOT NULL DEFAULT 0,
    workload_status VARCHAR(50),
    labels JSONB NOT NULL DEFAULT '{}',
    annotations JSONB NOT NULL DEFAULT '{}',
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    last_query_time TIMESTAMP,
    total_sum DOUBLE PRECISION DEFAULT 0,
    histogram JSONB DEFAULT '{"buckets": []}'
);

CREATE INDEX IF NOT EXISTS idx_workload_statistic_uid_time 
    ON workload_statistic(uid, stat_end_time DESC);
CREATE INDEX IF NOT EXISTS idx_workload_statistic_cluster_ns_wl_time 
    ON workload_statistic(cluster_name, namespace, workload_name, stat_end_time DESC);
CREATE INDEX IF NOT EXISTS idx_workload_statistic_uid_cluster_time 
    ON workload_statistic(uid, cluster_name, stat_end_time DESC);
CREATE INDEX IF NOT EXISTS idx_workload_statistic_workload_time 
    ON workload_statistic(workload_name, stat_end_time DESC);
CREATE INDEX IF NOT EXISTS idx_workload_statistic_type_time 
    ON workload_statistic(workload_type, stat_end_time DESC);
CREATE INDEX IF NOT EXISTS idx_workload_statistic_time 
    ON workload_statistic(stat_end_time DESC);
CREATE INDEX IF NOT EXISTS idx_workload_statistic_labels 
    ON workload_statistic USING GIN(labels);
CREATE INDEX IF NOT EXISTS idx_workload_statistic_annotations 
    ON workload_statistic USING GIN(annotations);
CREATE INDEX IF NOT EXISTS idx_workload_statistic_uid_cluster 
    ON workload_statistic(uid, cluster_name);
CREATE UNIQUE INDEX IF NOT EXISTS idx_workload_statistic_unique_active 
    ON workload_statistic(cluster_name, namespace, workload_name, uid)
    WHERE workload_status IN ('Running', 'Pending');
CREATE INDEX IF NOT EXISTS idx_workload_statistic_completed 
    ON workload_statistic(stat_end_time DESC)
    WHERE workload_status IN ('Completed', 'Failed', 'Deleted');
CREATE INDEX IF NOT EXISTS idx_workload_statistic_last_query 
    ON workload_statistic(last_query_time DESC)
    WHERE last_query_time IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_workload_statistic_histogram 
    ON workload_statistic USING GIN(histogram);

-- ============================================================================
-- Section 11: GPU Usage Weekly Reports Table
-- ============================================================================

CREATE TABLE IF NOT EXISTS gpu_usage_weekly_reports (
    id VARCHAR(64) PRIMARY KEY,
    cluster_name VARCHAR(128) NOT NULL,
    period_start TIMESTAMP NOT NULL,
    period_end TIMESTAMP NOT NULL,
    generated_at TIMESTAMP NOT NULL,
    status VARCHAR(32) NOT NULL DEFAULT 'pending',
    html_content BYTEA,
    pdf_content BYTEA,
    json_content JSONB,
    metadata JSONB,
    error_message TEXT,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX IF NOT EXISTS idx_gpu_weekly_reports_cluster_name 
    ON gpu_usage_weekly_reports(cluster_name);
CREATE INDEX IF NOT EXISTS idx_gpu_weekly_reports_status 
    ON gpu_usage_weekly_reports(status);
CREATE INDEX IF NOT EXISTS idx_gpu_weekly_reports_cluster_period 
    ON gpu_usage_weekly_reports(cluster_name, period_start DESC);
CREATE INDEX IF NOT EXISTS idx_gpu_weekly_reports_period_start 
    ON gpu_usage_weekly_reports(period_start DESC);
CREATE INDEX IF NOT EXISTS idx_gpu_weekly_reports_generated_at 
    ON gpu_usage_weekly_reports(generated_at DESC);
CREATE INDEX IF NOT EXISTS idx_gpu_weekly_reports_updated_at 
    ON gpu_usage_weekly_reports(updated_at DESC);
CREATE INDEX IF NOT EXISTS idx_gpu_weekly_reports_metadata 
    ON gpu_usage_weekly_reports USING GIN(metadata);
CREATE INDEX IF NOT EXISTS idx_gpu_weekly_reports_json_content 
    ON gpu_usage_weekly_reports USING GIN(json_content);

-- ============================================================================
-- Section 12: Framework Detection Tables
-- ============================================================================

CREATE TABLE IF NOT EXISTS framework_config (
    id SERIAL PRIMARY KEY,
    framework_name VARCHAR(64) NOT NULL UNIQUE,
    display_name VARCHAR(128),
    description TEXT,
    priority INTEGER NOT NULL DEFAULT 50,
    base_confidence DECIMAL(3,2) NOT NULL DEFAULT 0.70,
    enabled BOOLEAN NOT NULL DEFAULT true,
    config JSONB NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX IF NOT EXISTS idx_framework_config_enabled 
ON framework_config(enabled, priority DESC);
CREATE INDEX IF NOT EXISTS idx_framework_config_name
ON framework_config(framework_name);

CREATE TABLE IF NOT EXISTS detection_source_priority (
    id SERIAL PRIMARY KEY,
    source_name VARCHAR(64) NOT NULL UNIQUE,
    display_name VARCHAR(128),
    priority INTEGER NOT NULL,
    base_confidence DECIMAL(3,2) NOT NULL,
    confidence_decay DECIMAL(3,2) DEFAULT 1.0,
    enabled BOOLEAN NOT NULL DEFAULT true,
    description TEXT,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX IF NOT EXISTS idx_detection_source_priority_enabled
ON detection_source_priority(enabled, priority DESC);
CREATE INDEX IF NOT EXISTS idx_detection_source_priority_name
ON detection_source_priority(source_name);

CREATE TABLE IF NOT EXISTS workload_similarity_cache (
    id BIGSERIAL PRIMARY KEY,
    workload_uid_1 VARCHAR(128) NOT NULL,
    workload_uid_2 VARCHAR(128) NOT NULL,
    similarity_score DECIMAL(4,3) NOT NULL,
    signature_hash_1 VARCHAR(64) NOT NULL,
    signature_hash_2 VARCHAR(64) NOT NULL,
    calculated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMP NOT NULL,
    CONSTRAINT unique_workload_pair UNIQUE (workload_uid_1, workload_uid_2)
);

CREATE INDEX IF NOT EXISTS idx_similarity_cache_uid1_score
ON workload_similarity_cache(workload_uid_1, similarity_score DESC)
WHERE similarity_score >= 0.85;
CREATE INDEX IF NOT EXISTS idx_similarity_cache_uid2_score
ON workload_similarity_cache(workload_uid_2, similarity_score DESC)
WHERE similarity_score >= 0.85;
CREATE INDEX IF NOT EXISTS idx_similarity_cache_expires
ON workload_similarity_cache(expires_at);
CREATE INDEX IF NOT EXISTS idx_similarity_cache_signatures
ON workload_similarity_cache(signature_hash_1, signature_hash_2);

CREATE TABLE IF NOT EXISTS detection_conflict_log (
    id BIGSERIAL PRIMARY KEY,
    workload_uid VARCHAR(128) NOT NULL,
    source_1 VARCHAR(64) NOT NULL,
    source_2 VARCHAR(64) NOT NULL,
    framework_1 VARCHAR(64) NOT NULL,
    framework_2 VARCHAR(64) NOT NULL,
    confidence_1 DECIMAL(3,2) NOT NULL,
    confidence_2 DECIMAL(3,2) NOT NULL,
    resolution_strategy VARCHAR(64),
    resolved_framework VARCHAR(64),
    resolved_confidence DECIMAL(3,2),
    resolved_at TIMESTAMP,
    evidence_1 JSONB,
    evidence_2 JSONB,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX IF NOT EXISTS idx_detection_conflict_workload
ON detection_conflict_log(workload_uid, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_detection_conflict_sources
ON detection_conflict_log(source_1, source_2, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_detection_conflict_frameworks
ON detection_conflict_log(framework_1, framework_2);
CREATE INDEX IF NOT EXISTS idx_detection_conflict_created_at
ON detection_conflict_log(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_detection_conflict_resolution
ON detection_conflict_log(resolution_strategy, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_detection_conflict_evidence_gin
ON detection_conflict_log USING GIN (evidence_1 jsonb_path_ops);

CREATE TABLE IF NOT EXISTS framework_detection_metrics (
    id BIGSERIAL PRIMARY KEY,
    metric_time TIMESTAMP NOT NULL,
    source VARCHAR(64),
    framework VARCHAR(64),
    status VARCHAR(32),
    total_count INTEGER NOT NULL DEFAULT 0,
    conflict_count INTEGER DEFAULT 0,
    reuse_count INTEGER DEFAULT 0,
    avg_confidence DECIMAL(4,3),
    min_confidence DECIMAL(4,3),
    max_confidence DECIMAL(4,3),
    avg_detection_latency_ms INTEGER,
    p50_detection_latency_ms INTEGER,
    p95_detection_latency_ms INTEGER,
    p99_detection_latency_ms INTEGER,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX IF NOT EXISTS idx_detection_metrics_time
ON framework_detection_metrics(metric_time DESC);
CREATE INDEX IF NOT EXISTS idx_detection_metrics_source_framework
ON framework_detection_metrics(source, framework, metric_time DESC);
CREATE INDEX IF NOT EXISTS idx_detection_metrics_status
ON framework_detection_metrics(status, metric_time DESC);
CREATE INDEX IF NOT EXISTS idx_detection_metrics_framework
ON framework_detection_metrics(framework, metric_time DESC);
CREATE INDEX IF NOT EXISTS idx_detection_metrics_composite
ON framework_detection_metrics(metric_time DESC, framework, source, status);

CREATE TABLE IF NOT EXISTS reuse_effectiveness_log (
    id BIGSERIAL PRIMARY KEY,
    workload_uid VARCHAR(128) NOT NULL,
    reused_from VARCHAR(128) NOT NULL,
    similarity_score DECIMAL(4,3) NOT NULL,
    reused_framework VARCHAR(64) NOT NULL,
    reused_confidence DECIMAL(3,2) NOT NULL,
    verified_by VARCHAR(64),
    verified_framework VARCHAR(64),
    verified_at TIMESTAMP,
    is_correct BOOLEAN,
    time_saved_ms INTEGER,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX IF NOT EXISTS idx_reuse_effectiveness_workload
ON reuse_effectiveness_log(workload_uid);
CREATE INDEX IF NOT EXISTS idx_reuse_effectiveness_from
ON reuse_effectiveness_log(reused_from);
CREATE INDEX IF NOT EXISTS idx_reuse_effectiveness_correct
ON reuse_effectiveness_log(is_correct, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_reuse_effectiveness_framework
ON reuse_effectiveness_log(reused_framework, is_correct);
CREATE INDEX IF NOT EXISTS idx_reuse_effectiveness_created_at
ON reuse_effectiveness_log(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_reuse_effectiveness_similarity
ON reuse_effectiveness_log(similarity_score DESC, is_correct);
CREATE INDEX IF NOT EXISTS idx_reuse_effectiveness_analytics
ON reuse_effectiveness_log(created_at DESC, reused_framework, is_correct);

-- ============================================================================
-- Section 13: Alert System Tables
-- ============================================================================

CREATE TABLE IF NOT EXISTS alert_events (
    id VARCHAR(64) PRIMARY KEY,
    source VARCHAR(20) NOT NULL,
    alert_name VARCHAR(255) NOT NULL,
    severity VARCHAR(20) NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'firing',
    starts_at TIMESTAMP NOT NULL,
    ends_at TIMESTAMP,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    labels JSONB NOT NULL,
    annotations JSONB,
    workload_id VARCHAR(255),
    pod_name VARCHAR(255),
    pod_id VARCHAR(255),
    node_name VARCHAR(255),
    cluster_name VARCHAR(100),
    raw_data JSONB,
    enriched_data JSONB,
    route_key VARCHAR(255),
    notified_at TIMESTAMP,
    notification_status VARCHAR(50)
);

CREATE INDEX IF NOT EXISTS idx_alert_events_source_status ON alert_events(source, status);
CREATE INDEX IF NOT EXISTS idx_alert_events_starts_at ON alert_events(starts_at DESC);
CREATE INDEX IF NOT EXISTS idx_alert_events_alert_name ON alert_events(alert_name);
CREATE INDEX IF NOT EXISTS idx_alert_events_workload ON alert_events(workload_id);
CREATE INDEX IF NOT EXISTS idx_alert_events_pod ON alert_events(pod_name);
CREATE INDEX IF NOT EXISTS idx_alert_events_node ON alert_events(node_name);
CREATE INDEX IF NOT EXISTS idx_alert_events_labels ON alert_events USING GIN(labels);

CREATE TABLE IF NOT EXISTS alert_correlations (
    id BIGSERIAL PRIMARY KEY,
    correlation_id VARCHAR(64) NOT NULL,
    alert_id VARCHAR(64) NOT NULL,
    correlation_type VARCHAR(50) NOT NULL,
    correlation_score DOUBLE PRECISION,
    correlation_reason TEXT,
    correlation_metadata JSONB,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT fk_alert_correlations_alert FOREIGN KEY (alert_id) REFERENCES alert_events(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_alert_correlations_correlation_id ON alert_correlations(correlation_id);
CREATE INDEX IF NOT EXISTS idx_alert_correlations_alert_id ON alert_correlations(alert_id);

CREATE TABLE IF NOT EXISTS alert_statistics (
    id BIGSERIAL PRIMARY KEY,
    date DATE NOT NULL,
    hour INTEGER,
    alert_name VARCHAR(255) NOT NULL,
    source VARCHAR(20) NOT NULL,
    severity VARCHAR(20) NOT NULL,
    workload_id VARCHAR(255),
    cluster_name VARCHAR(100),
    firing_count INTEGER DEFAULT 0,
    resolved_count INTEGER DEFAULT 0,
    total_duration_seconds BIGINT DEFAULT 0,
    avg_duration_seconds DOUBLE PRECISION,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT uk_alert_statistics UNIQUE (date, hour, alert_name, source, workload_id, cluster_name)
);

CREATE INDEX IF NOT EXISTS idx_alert_statistics_date ON alert_statistics(date DESC);

CREATE TABLE IF NOT EXISTS alert_rules (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(255) UNIQUE NOT NULL,
    source VARCHAR(20) NOT NULL,
    enabled BOOLEAN DEFAULT TRUE,
    rule_type VARCHAR(50) NOT NULL,
    rule_config JSONB NOT NULL,
    severity VARCHAR(20) DEFAULT 'warning',
    labels JSONB,
    annotations JSONB,
    route_config JSONB,
    inhibit_rules JSONB,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_by VARCHAR(255)
);

CREATE INDEX IF NOT EXISTS idx_alert_rules_source_enabled ON alert_rules(source, enabled);
CREATE INDEX IF NOT EXISTS idx_alert_rules_name ON alert_rules(name);

CREATE TABLE IF NOT EXISTS alert_silences (
    id VARCHAR(64) PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    cluster_name VARCHAR(100),
    enabled BOOLEAN DEFAULT TRUE,
    silence_type VARCHAR(50) NOT NULL,
    resource_filters JSONB,
    label_matchers JSONB,
    alert_names JSONB,
    match_expression TEXT,
    starts_at TIMESTAMP NOT NULL,
    ends_at TIMESTAMP,
    time_windows JSONB,
    reason TEXT,
    ticket_url VARCHAR(500),
    created_by VARCHAR(255),
    updated_by VARCHAR(255),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX IF NOT EXISTS idx_alert_silences_cluster ON alert_silences(cluster_name);
CREATE INDEX IF NOT EXISTS idx_alert_silences_enabled ON alert_silences(enabled);
CREATE INDEX IF NOT EXISTS idx_alert_silences_type ON alert_silences(silence_type);
CREATE INDEX IF NOT EXISTS idx_alert_silences_time_range ON alert_silences(starts_at, ends_at);
CREATE INDEX IF NOT EXISTS idx_alert_silences_active ON alert_silences(enabled, starts_at, ends_at) WHERE enabled = true;

CREATE TABLE IF NOT EXISTS silenced_alerts (
    id BIGSERIAL PRIMARY KEY,
    silence_id VARCHAR(64) NOT NULL,
    alert_id VARCHAR(64) NOT NULL,
    alert_name VARCHAR(255) NOT NULL,
    cluster_name VARCHAR(100),
    silenced_at TIMESTAMP NOT NULL,
    reason TEXT,
    alert_data JSONB,
    CONSTRAINT fk_silence FOREIGN KEY (silence_id) REFERENCES alert_silences(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_silenced_alerts_silence_id ON silenced_alerts(silence_id);
CREATE INDEX IF NOT EXISTS idx_silenced_alerts_alert_id ON silenced_alerts(alert_id);
CREATE INDEX IF NOT EXISTS idx_silenced_alerts_alert_name ON silenced_alerts(alert_name);
CREATE INDEX IF NOT EXISTS idx_silenced_alerts_silenced_at ON silenced_alerts(silenced_at DESC);

CREATE TABLE IF NOT EXISTS alert_notifications (
    id BIGSERIAL PRIMARY KEY,
    alert_id VARCHAR(64) NOT NULL,
    channel VARCHAR(50) NOT NULL,
    channel_config JSONB,
    status VARCHAR(20) NOT NULL,
    sent_at TIMESTAMP,
    error_message TEXT,
    retry_count INTEGER DEFAULT 0,
    notification_payload JSONB,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT fk_alert_notifications_alert FOREIGN KEY (alert_id) REFERENCES alert_events(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_alert_notifications_alert_id ON alert_notifications(alert_id);
CREATE INDEX IF NOT EXISTS idx_alert_notifications_status ON alert_notifications(status);
CREATE INDEX IF NOT EXISTS idx_alert_notifications_created_at ON alert_notifications(created_at DESC);

-- ============================================================================
-- Section 14: Metric Alert Rules Tables
-- ============================================================================

CREATE TABLE IF NOT EXISTS metric_alert_rules (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    cluster_name VARCHAR(100) NOT NULL,
    enabled BOOLEAN DEFAULT TRUE,
    groups JSONB NOT NULL,
    description TEXT,
    labels JSONB,
    sync_status VARCHAR(50) DEFAULT 'pending',
    sync_message TEXT,
    last_sync_at TIMESTAMP,
    vmrule_uid VARCHAR(255),
    vmrule_status JSONB,
    resource_mapping JSONB,
    alert_enrichment JSONB,
    alert_grouping JSONB,
    alert_routing JSONB,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_by VARCHAR(255),
    updated_by VARCHAR(255),
    CONSTRAINT uk_metric_alert_rule_name_cluster UNIQUE (name, cluster_name)
);

CREATE INDEX IF NOT EXISTS idx_metric_alert_rules_cluster ON metric_alert_rules(cluster_name);
CREATE INDEX IF NOT EXISTS idx_metric_alert_rules_enabled ON metric_alert_rules(enabled);
CREATE INDEX IF NOT EXISTS idx_metric_alert_rules_sync_status ON metric_alert_rules(sync_status);
CREATE INDEX IF NOT EXISTS idx_metric_alert_rules_created_at ON metric_alert_rules(created_at DESC);

-- ============================================================================
-- Section 15: Log Alert Rules Tables
-- ============================================================================

CREATE TABLE IF NOT EXISTS log_alert_rules (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    cluster_name VARCHAR(100) NOT NULL,
    enabled BOOLEAN DEFAULT true,
    priority INT DEFAULT 5,
    label_selectors JSONB NOT NULL,
    match_type VARCHAR(50) NOT NULL,
    match_config JSONB NOT NULL,
    severity VARCHAR(20) DEFAULT 'warning',
    alert_template JSONB,
    group_by TEXT[],
    group_wait BIGINT DEFAULT 30,
    repeat_interval BIGINT DEFAULT 3600,
    route_config JSONB,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    created_by VARCHAR(255),
    updated_by VARCHAR(255),
    last_triggered_at TIMESTAMP,
    trigger_count BIGINT DEFAULT 0,
    CONSTRAINT uq_log_alert_rule_name_cluster UNIQUE (name, cluster_name)
);

CREATE INDEX IF NOT EXISTS idx_log_alert_rules_cluster_enabled 
    ON log_alert_rules(cluster_name, enabled);
CREATE INDEX IF NOT EXISTS idx_log_alert_rules_priority 
    ON log_alert_rules(priority DESC);
CREATE INDEX IF NOT EXISTS idx_log_alert_rules_label_selectors 
    ON log_alert_rules USING GIN(label_selectors);
CREATE INDEX IF NOT EXISTS idx_log_alert_rules_created_at 
    ON log_alert_rules(created_at DESC);

CREATE TABLE IF NOT EXISTS log_alert_rule_versions (
    id BIGSERIAL PRIMARY KEY,
    rule_id BIGINT NOT NULL,
    version INT NOT NULL,
    config JSONB NOT NULL,
    status VARCHAR(20) DEFAULT 'draft',
    deployed_at TIMESTAMP,
    created_by VARCHAR(255),
    created_at TIMESTAMP DEFAULT NOW(),
    change_log TEXT,
    CONSTRAINT fk_log_alert_rule_version_rule 
        FOREIGN KEY (rule_id) 
        REFERENCES log_alert_rules(id) 
        ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_log_alert_rule_versions_rule_id 
    ON log_alert_rule_versions(rule_id);
CREATE INDEX IF NOT EXISTS idx_log_alert_rule_versions_rule_version 
    ON log_alert_rule_versions(rule_id, version DESC);

CREATE TABLE IF NOT EXISTS log_alert_rule_statistics (
    id BIGSERIAL PRIMARY KEY,
    rule_id BIGINT NOT NULL,
    date DATE NOT NULL,
    hour INT,
    cluster_name VARCHAR(100) NOT NULL,
    evaluated_count BIGINT DEFAULT 0,
    matched_count BIGINT DEFAULT 0,
    fired_count BIGINT DEFAULT 0,
    avg_eval_time_ms FLOAT,
    max_eval_time_ms FLOAT,
    error_count BIGINT DEFAULT 0,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    CONSTRAINT uq_log_alert_rule_stat_unique 
        UNIQUE (rule_id, date, hour, cluster_name)
);

CREATE INDEX IF NOT EXISTS idx_log_alert_rule_statistics_date 
    ON log_alert_rule_statistics(date DESC);
CREATE INDEX IF NOT EXISTS idx_log_alert_rule_statistics_rule_date 
    ON log_alert_rule_statistics(rule_id, date DESC);

CREATE TABLE IF NOT EXISTS log_alert_rule_templates (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(255) UNIQUE NOT NULL,
    category VARCHAR(50) NOT NULL,
    description TEXT,
    template_config JSONB NOT NULL,
    tags TEXT[],
    is_builtin BOOLEAN DEFAULT false,
    usage_count BIGINT DEFAULT 0,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    created_by VARCHAR(255)
);

CREATE INDEX IF NOT EXISTS idx_log_alert_rule_templates_category 
    ON log_alert_rule_templates(category);
CREATE INDEX IF NOT EXISTS idx_log_alert_rule_templates_usage_count 
    ON log_alert_rule_templates(usage_count DESC);
CREATE INDEX IF NOT EXISTS idx_log_alert_rule_templates_is_builtin 
    ON log_alert_rule_templates(is_builtin);

-- ============================================================================
-- Section 16: Alert Rule Advices Tables
-- ============================================================================

CREATE TABLE IF NOT EXISTS alert_rule_advices (
    id BIGSERIAL PRIMARY KEY,
    rule_type VARCHAR(20) NOT NULL,
    name VARCHAR(255) NOT NULL,
    title VARCHAR(255) NOT NULL,
    description TEXT,
    category VARCHAR(50) NOT NULL,
    cluster_name VARCHAR(100) NOT NULL,
    target_resource VARCHAR(50),
    target_name VARCHAR(255),
    rule_config JSONB NOT NULL,
    severity VARCHAR(20) DEFAULT 'warning',
    priority INT DEFAULT 5,
    reason TEXT,
    evidence JSONB,
    status VARCHAR(20) DEFAULT 'pending',
    reviewed_by VARCHAR(255),
    reviewed_at TIMESTAMP,
    review_notes TEXT,
    applied_rule_id BIGINT,
    applied_at TIMESTAMP,
    inspection_id VARCHAR(100),
    inspection_time TIMESTAMP NOT NULL,
    tags TEXT[],
    confidence_score FLOAT DEFAULT 0.5,
    expires_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    created_by VARCHAR(255)
);

CREATE INDEX IF NOT EXISTS idx_alert_rule_advices_rule_type 
    ON alert_rule_advices(rule_type);
CREATE INDEX IF NOT EXISTS idx_alert_rule_advices_category 
    ON alert_rule_advices(category);
CREATE INDEX IF NOT EXISTS idx_alert_rule_advices_cluster_name 
    ON alert_rule_advices(cluster_name);
CREATE INDEX IF NOT EXISTS idx_alert_rule_advices_status 
    ON alert_rule_advices(status);
CREATE INDEX IF NOT EXISTS idx_alert_rule_advices_inspection_id 
    ON alert_rule_advices(inspection_id);
CREATE INDEX IF NOT EXISTS idx_alert_rule_advices_created_at 
    ON alert_rule_advices(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_alert_rule_advices_expires_at 
    ON alert_rule_advices(expires_at);
CREATE INDEX IF NOT EXISTS idx_alert_rule_advices_rule_config 
    ON alert_rule_advices USING GIN(rule_config);
CREATE INDEX IF NOT EXISTS idx_alert_rule_advices_evidence 
    ON alert_rule_advices USING GIN(evidence);
CREATE INDEX IF NOT EXISTS idx_alert_rule_advices_cluster_status 
    ON alert_rule_advices(cluster_name, status, created_at DESC);

CREATE TABLE IF NOT EXISTS alert_rule_advice_statistics (
    id BIGSERIAL PRIMARY KEY,
    cluster_name VARCHAR(100) NOT NULL,
    date DATE NOT NULL,
    log_rule_count BIGINT DEFAULT 0,
    metric_rule_count BIGINT DEFAULT 0,
    performance_count BIGINT DEFAULT 0,
    error_count BIGINT DEFAULT 0,
    resource_count BIGINT DEFAULT 0,
    security_count BIGINT DEFAULT 0,
    availability_count BIGINT DEFAULT 0,
    pending_count BIGINT DEFAULT 0,
    reviewed_count BIGINT DEFAULT 0,
    accepted_count BIGINT DEFAULT 0,
    rejected_count BIGINT DEFAULT 0,
    applied_count BIGINT DEFAULT 0,
    avg_confidence_score FLOAT,
    avg_priority FLOAT,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    CONSTRAINT uq_alert_rule_advice_stat_cluster_date 
        UNIQUE (cluster_name, date)
);

CREATE INDEX IF NOT EXISTS idx_alert_rule_advice_statistics_date 
    ON alert_rule_advice_statistics(date DESC);
CREATE INDEX IF NOT EXISTS idx_alert_rule_advice_statistics_cluster_date 
    ON alert_rule_advice_statistics(cluster_name, date DESC);

-- ============================================================================
-- Section 17: Default Configuration Data
-- ============================================================================

-- Insert default framework configurations
INSERT INTO framework_config (framework_name, display_name, priority, base_confidence, config) VALUES
('primus', 'Primus', 80, 0.75, '{
    "log_patterns": [
        {"pattern": "primus-rocm-memory", "weight": 1.0, "category": "memory", "description": "Primus ROCm memory allocation"},
        {"pattern": "PrimusTrainer", "weight": 0.9, "category": "framework", "description": "Primus trainer initialization"},
        {"pattern": "primus\\.distributed", "weight": 0.8, "category": "distributed", "description": "Primus distributed training"}
    ],
    "image_patterns": ["primus", "primus-training"],
    "env_keys": ["PRIMUS_CONFIG", "PRIMUS_MASTER_ADDR"],
    "label_keys": ["ai.amd.com/framework"]
}'::jsonb),
('deepspeed', 'DeepSpeed', 75, 0.75, '{
    "log_patterns": [
        {"pattern": "DeepSpeed Engine", "weight": 1.0, "category": "framework", "description": "DeepSpeed engine initialization"},
        {"pattern": "deepspeed\\.runtime", "weight": 0.9, "category": "runtime", "description": "DeepSpeed runtime"}
    ],
    "image_patterns": ["deepspeed"],
    "env_keys": ["DEEPSPEED_CONFIG"],
    "label_keys": ["ai.amd.com/framework"]
}'::jsonb),
('megatron', 'Megatron-LM', 75, 0.75, '{
    "log_patterns": [
        {"pattern": "Megatron-LM", "weight": 1.0, "category": "framework", "description": "Megatron-LM framework"},
        {"pattern": "megatron\\.model", "weight": 0.9, "category": "model", "description": "Megatron model initialization"}
    ],
    "image_patterns": ["megatron", "megatron-lm"],
    "env_keys": ["MEGATRON_CONFIG"],
    "label_keys": ["ai.amd.com/framework"]
}'::jsonb)
ON CONFLICT (framework_name) DO NOTHING;

-- Insert default detection source priorities
INSERT INTO detection_source_priority (source_name, display_name, priority, base_confidence, confidence_decay, description) VALUES
('user', 'User Annotation', 100, 1.0, 1.0, 'Manual user annotation, highest priority'),
('component', 'Component Detection', 80, 0.85, 1.0, 'Detected by component through image, labels, etc.'),
('reuse', 'Reuse Detection', 75, 0.85, 0.9, 'Reused results from similar workload'),
('log', 'Log Analysis', 60, 0.70, 1.0, 'Identified through log pattern matching'),
('image', 'Image Inference', 40, 0.60, 1.0, 'Inferred from image name only'),
('default', 'Default Inference', 20, 0.30, 1.0, 'Default or unknown case')
ON CONFLICT (source_name) DO NOTHING;

-- Insert Primus framework log patterns configuration
INSERT INTO system_config (key, value, description, created_at, updated_at) VALUES
('training.log.parser.framework.primus', '{
  "name": "primus",
  "display_name": "Primus",
  "version": "1.0.0",
  "priority": 80,
  "enabled": true,
  "identify_patterns": [
    {
      "name": "primus-iteration-log",
      "pattern": "iteration\\s+\\d+\\s*/\\s*\\d+.*throughput\\s+per\\s+GPU",
      "description": "Primus iteration performance log identifier",
      "enabled": true,
      "tags": ["performance", "iteration"],
      "confidence": 0.3
    },
    {
      "name": "primus-trainer",
      "pattern": "PRIMUS_PATH",
      "description": "Primus trainer initialization",
      "enabled": true,
      "tags": ["framework"],
      "confidence": 1.0
    }
  ],
  "performance_patterns": [
    {
      "name": "primus-rocm-memory",
      "pattern": ".*iteration\\s+(?P<CurrentIteration>\\d+)\\s*/\\s*(?P<TargetIteration>\\d+)\\s*\\|\\s*consumed samples:\\s+(?P<ConsumedSamples>\\d+)\\s*\\|\\s*elapsed\\stime\\sper\\siteration\\s\\(ms\\):\\s+(?P<ElapsedTimePerIterationMS>\\d+(?:\\.\\d+)*)/\\d+(?:\\.\\d+)*\\s+\\|\\s+rocm\\s+mem\\s+usage/free/total/usage_ratio:\\s+(?P<MemUsage>\\d+\\.\\d+)GB/(?P<MemFree>\\d+\\.\\d+)GB/(?P<MemTotal>\\d+\\.\\d+)GB/(?P<MemUsageRatio>\\d+\\.\\d+)%\\s+\\|\\s+throughput\\s+per\\s+GPU\\s+\\(TFLOP/s/GPU\\):\\s+(?P<TFLOPS>\\d+(?:\\.\\d+)*)/\\d+(?:\\.\\d+)*\\s+\\|\\s+tokens\\s+per\\s+GPU\\s+\\(tokens/s/GPU\\):\\s+(?P<TokensPerGPU>\\d+(?:\\.\\d+)*)/\\d+(?:\\.\\d+)*\\s+\\|\\s*learning\\s+rate:\\s+(?P<LearningRate>[+-]?\\d+(?:\\.\\d+)?(?:[Ee][+-]?\\d+)?)\\s*\\|\\s+global\\s+batch\\s+size:\\s+(?P<GlobalBatchSize>\\d+(?:\\.\\d+)*)\\s+\\|\\s+lm\\s+loss:\\s+(?P<LmLoss>[+-]?\\d+(?:\\.\\d+)?(?:[Ee][+-]?\\d+)?)\\s+\\|\\s+loss\\s+scale:\\s+(?P<LossScale>\\d+(?:\\.\\d+)*)\\s+\\|\\s+grad\\s+norm:\\s+(?P<GradNorm>\\d+(?:\\.\\d+)*)\\s+\\|\\s+num\\s+zeros:\\s(?P<NumZeros>\\d+(?:\\.\\d+)*)\\s+\\|\\s+number\\s+of\\s+skipped\\s+iterations:\\s+(?P<SkippedIterationsNumber>\\d+)\\s+\\|\\s+number\\s+of\\s+nan\\s+iterations:\\s+(?P<NanIterationsNumber>\\d+)\\s*\\|.*",
      "description": "Primus performance log with ROCm memory metrics",
      "enabled": true,
      "tags": ["performance", "rocm", "memory"],
      "confidence": 1.0
    },
    {
      "name": "primus-hip-memory",
      "pattern": ".*iteration\\s+(?P<CurrentIteration>\\d+)\\s*/\\s*(?P<TargetIteration>\\d+)\\s*\\|\\s*consumed samples:\\s+(?P<ConsumedSamples>\\d+)\\s*\\|\\s*elapsed\\stime\\sper\\siteration\\s\\(ms\\):\\s+(?P<ElapsedTimePerIterationMS>\\d+(?:\\.\\d+)*)/\\d+(?:\\.\\d+)*\\s+\\|\\s+hip\\s+mem\\s+usage/free/total/usage_ratio:\\s+(?P<MemUsage>\\d+\\.\\d+)GB/(?P<MemFree>\\d+\\.\\d+)GB/(?P<MemTotal>\\d+\\.\\d+)GB/(?P<MemUsageRatio>\\d+\\.\\d+)%\\s+\\|\\s+throughput\\s+per\\s+GPU\\s+\\(TFLOP/s/GPU\\):\\s+(?P<TFLOPS>\\d+(?:\\.\\d+)*)/\\d+(?:\\.\\d+)*\\s+\\|\\s+tokens\\s+per\\s+GPU\\s+\\(tokens/s/GPU\\):\\s+(?P<TokensPerGPU>\\d+(?:\\.\\d+)*)/\\d+(?:\\.\\d+)*\\s+\\|\\s*learning\\s+rate:\\s+(?P<LearningRate>[+-]?\\d+(?:\\.\\d+)?(?:[Ee][+-]?\\d+)?)\\s*\\|\\s+global\\s+batch\\s+size:\\s+(?P<GlobalBatchSize>\\d+(?:\\.\\d+)*)\\s+\\|\\s+lm\\s+loss:\\s+(?P<LmLoss>[+-]?\\d+(?:\\.\\d+)?(?:[Ee][+-]?\\d+)?)\\s+\\|\\s+loss\\s+scale:\\s+(?P<LossScale>\\d+(?:\\.\\d+)*)\\s+\\|\\s+grad\\s+norm:\\s+(?P<GradNorm>\\d+(?:\\.\\d+)*)\\s+\\|\\s+num\\s+zeros:\\s(?P<NumZeros>\\d+(?:\\.\\d+)*)\\s+\\|\\s+number\\s+of\\s+skipped\\s+iterations:\\s+(?P<SkippedIterationsNumber>\\d+)\\s+\\|\\s+number\\s+of\\s+nan\\s+iterations:\\s+(?P<NanIterationsNumber>\\d+)\\s*\\|.*",
      "description": "Primus performance log with HIP memory metrics",
      "enabled": true,
      "tags": ["performance", "hip", "memory"],
      "confidence": 1.0
    },
    {
      "name": "primus-legacy",
      "pattern": ".*iteration\\s+(?P<CurrentIteration>\\d+)\\s*/\\s*(?P<TargetIteration>\\d+)\\s*\\|\\s*consumed samples:\\s+(?P<ConsumedSamples>\\d+)\\s*\\|\\s*elapsed\\stime\\sper\\siteration\\s\\(ms\\):\\s+(?P<ElapsedTimePerIterationMS>\\d+(?:\\.\\d+)*)/\\d+(?:\\.\\d+)*\\s+\\|\\s+mem\\s+usages:\\s+(?P<MemUsages>\\d+\\.\\d+)\\s+\\|\\s+throughput\\s+per\\s+GPU\\s+\\(TFLOP/s/GPU\\):\\s+(?P<TFLOPS>\\d+(?:\\.\\d+)*)/\\d+(?:\\.\\d+)*\\s+\\|\\s+tokens\\s+per\\s+GPU\\s+\\(tokens/s/GPU\\):\\s+(?P<TokensPerGPU>\\d+(?:\\.\\d+)*)/\\d+(?:\\.\\d+)*\\s+\\|\\s+learning\\s+rate:\\s+(?P<LearningRate>[+-]?\\d+(?:\\.\\d+)?(?:[Ee][+-]?\\d+)?)\\s+\\|\\s+global\\s+batch\\s+size:\\s+(?P<GlobalBatchSize>\\d+(?:\\.\\d+)*)\\s+\\|\\s+lm\\s+loss:\\s+(?P<LmLoss>[+-]?\\d+(?:\\.\\d+)?(?:[Ee][+-]?\\d+)?)\\s+\\|\\s+loss\\s+scale:\\s+(?P<LossScale>\\d+(?:\\.\\d+)*)\\s+\\|\\s+grad\\s+norm:\\s+(?P<GradNorm>\\d+(?:\\.\\d+)*)\\s+\\|\\s+num\\s+zeros:\\s(?P<NumZeros>\\d+(?:\\.\\d+)*)\\s+\\|\\s+number\\s+of\\s+skipped\\s+iterations:\\s+(?P<SkippedIterationsNumber>\\d+)\\s+\\|\\s+number\\s+of\\s+nan\\s+iterations:\\s+(?P<NanIterationsNumber>\\d+)\\s*\\|.*",
      "description": "Primus legacy format performance log (without detailed memory metrics)",
      "enabled": true,
      "tags": ["performance", "legacy"],
      "confidence": 0.95
    }
  ],
  "training_events": {
    "start_training": [
      {
        "name": "training-start",
        "pattern": "training\\s+\\.\\.\\.",
        "description": "Training started marker",
        "enabled": true,
        "tags": ["lifecycle", "start"],
        "confidence": 1.0
      }
    ],
    "end_training": [],
    "pause_training": [],
    "resume_training": []
  },
  "checkpoint_events": {
    "start_saving": [],
    "end_saving": [],
    "loading": []
  },
  "extensions": {
    "supports_rocm": true,
    "supports_hip": true,
    "memory_tracking": true
  },
  "updated_at": "2024-01-01T00:00:00Z",
  "created_at": "2024-01-01T00:00:00Z"
}'::jsonb, 'Primus framework log patterns configuration', NOW(), NOW())
ON CONFLICT (key) 
DO UPDATE SET 
  value = EXCLUDED.value,
  updated_at = NOW(),
  description = EXCLUDED.description;

-- Insert DeepSpeed framework configuration
INSERT INTO system_config (key, value, description, created_at, updated_at)
VALUES (
    'training.log.parser.framework.deepspeed',
    '{
        "name": "deepspeed",
        "display_name": "DeepSpeed",
        "version": "1.0.0",
        "priority": 90,
        "enabled": true,
        "identify_patterns": [
            {
                "name": "deepspeed-identifier",
                "pattern": "deepspeed|DeepSpeed|DEEPSPEED",
                "description": "Identify DeepSpeed framework from log content",
                "enabled": true,
                "tags": ["identify"],
                "confidence": 0.7
            }
        ],
        "performance_patterns": [],
        "training_events": {
            "start_training": []
        },
        "checkpoint_events": {
            "start_saving": [],
            "end_saving": []
        },
        "extensions": {},
        "updated_at": "2024-01-01T00:00:00Z",
        "created_at": "2024-01-01T00:00:00Z"
    }',
    'Log parsing patterns for DeepSpeed framework',
    NOW(),
    NOW()
)
ON CONFLICT (key) DO UPDATE SET
    value = EXCLUDED.value,
    description = EXCLUDED.description,
    updated_at = NOW();

-- Insert Megatron framework configuration
INSERT INTO system_config (key, value, description, created_at, updated_at)
VALUES (
    'training.log.parser.framework.megatron',
    '{
        "name": "megatron",
        "display_name": "Megatron-LM",
        "version": "1.0.0",
        "priority": 80,
        "enabled": true,
        "identify_patterns": [
            {
                "name": "megatron-identifier",
                "pattern": "megatron|Megatron|MEGATRON",
                "description": "Identify Megatron framework from log content",
                "enabled": true,
                "tags": ["identify"],
                "confidence": 0.7
            }
        ],
        "performance_patterns": [],
        "training_events": {
            "start_training": []
        },
        "checkpoint_events": {
            "start_saving": [],
            "end_saving": []
        },
        "extensions": {},
        "updated_at": "2024-01-01T00:00:00Z",
        "created_at": "2024-01-01T00:00:00Z"
    }',
    'Log parsing patterns for Megatron framework',
    NOW(),
    NOW()
)
ON CONFLICT (key) DO UPDATE SET
    value = EXCLUDED.value,
    description = EXCLUDED.description,
    updated_at = NOW();

-- ============================================================================
-- Section 18: Grant ownership of all tables to primus-lens user
-- ============================================================================

DO
$$
    DECLARE
        r RECORD;
    BEGIN
        FOR r IN SELECT tablename FROM pg_tables WHERE schemaname = 'public'
            LOOP
                EXECUTE format('ALTER TABLE public.%I OWNER TO "primus-lens";', r.tablename);
            END LOOP;
    END
$$;

