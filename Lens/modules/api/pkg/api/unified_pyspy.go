// Copyright (C) 2025-2026, Advanced Micro Devices, Inc. All rights reserved.
// See LICENSE for license information.

package api

import (
	"context"
	"fmt"
	"path/filepath"
	"time"

	"github.com/AMD-AGI/Primus-SaFE/Lens/core/pkg/clientsets"
	"github.com/AMD-AGI/Primus-SaFE/Lens/core/pkg/constant"
	"github.com/AMD-AGI/Primus-SaFE/Lens/core/pkg/database"
	"github.com/AMD-AGI/Primus-SaFE/Lens/core/pkg/database/model"
	"github.com/AMD-AGI/Primus-SaFE/Lens/core/pkg/errors"
	"github.com/AMD-AGI/Primus-SaFE/Lens/core/pkg/mcp/unified"
)

func init() {
	// Py-Spy profiling endpoints (GET only)
	unified.Register(&unified.EndpointDef[PySpyTaskGetRequest, PySpyTaskResponse]{
		Name:        "pyspy_task_get",
		Description: "Get a specific py-spy profiling task by ID",
		HTTPMethod:  "GET",
		HTTPPath:    "/pyspy/task/:id",
		MCPToolName: "lens_pyspy_task_get",
		Handler:     handlePySpyTaskGet,
	})

	unified.Register(&unified.EndpointDef[PySpyTaskFilesRequest, PySpyTaskFilesResponse]{
		Name:        "pyspy_task_files",
		Description: "List files generated by a py-spy profiling task",
		HTTPMethod:  "GET",
		HTTPPath:    "/pyspy/file/:task_id",
		MCPToolName: "lens_pyspy_task_files",
		Handler:     handlePySpyTaskFiles,
	})
}

// ======================== Request Types ========================

type PySpyTaskGetRequest struct {
	Cluster string `json:"cluster" query:"cluster" mcp:"description=Cluster name"`
	ID      string `json:"id" form:"id" param:"id" binding:"required" mcp:"description=Task ID,required"`
}

type PySpyTaskFilesRequest struct {
	Cluster string `json:"cluster" query:"cluster" mcp:"description=Cluster name"`
	TaskID  string `json:"task_id" form:"task_id" param:"task_id" binding:"required" mcp:"description=Task ID,required"`
}

// ======================== Response Types ========================

type PySpyTaskResponse struct {
	TaskID       string     `json:"task_id"`
	Status       string     `json:"status"`
	PodUID       string     `json:"pod_uid,omitempty"`
	PodName      string     `json:"pod_name,omitempty"`
	PodNamespace string     `json:"pod_namespace,omitempty"`
	NodeName     string     `json:"node_name,omitempty"`
	PID          int        `json:"pid,omitempty"`
	Duration     int        `json:"duration,omitempty"`
	Format       string     `json:"format,omitempty"`
	OutputFile   string     `json:"output_file,omitempty"`
	FilePath     string     `json:"file_path,omitempty"`
	FileSize     int64      `json:"file_size,omitempty"`
	Error        string     `json:"error,omitempty"`
	CreatedAt    time.Time  `json:"created_at"`
	StartedAt    *time.Time `json:"started_at,omitempty"`
	CompletedAt  *time.Time `json:"completed_at,omitempty"`
}

type PySpyTaskFilesResponse struct {
	TaskID string                   `json:"task_id"`
	Files  []map[string]interface{} `json:"files"`
}

// ======================== Handler Implementations ========================

func handlePySpyTaskGet(ctx context.Context, req *PySpyTaskGetRequest) (*PySpyTaskResponse, error) {
	if req.ID == "" {
		return nil, errors.NewError().WithCode(errors.RequestParameterInvalid).WithMessage("task id is required")
	}

	cm := clientsets.GetClusterManager()
	clients, err := cm.GetClusterClientsOrDefault(req.Cluster)
	if err != nil {
		return nil, err
	}

	taskFacade := getPySpyTaskFacadeForCluster(clients.ClusterName)
	task, err := taskFacade.GetTask(ctx, req.ID, constant.TaskTypePySpySample)
	if err != nil {
		return nil, errors.WrapError(err, "failed to get task", errors.CodeDatabaseError)
	}

	if task == nil {
		return nil, errors.NewError().WithCode(errors.RequestDataNotExisted).WithMessage("task not found")
	}

	return pySpyTaskToResponse(task), nil
}

func handlePySpyTaskFiles(ctx context.Context, req *PySpyTaskFilesRequest) (*PySpyTaskFilesResponse, error) {
	if req.TaskID == "" {
		return nil, errors.NewError().WithCode(errors.RequestParameterInvalid).WithMessage("task_id is required")
	}

	cm := clientsets.GetClusterManager()
	clients, err := cm.GetClusterClientsOrDefault(req.Cluster)
	if err != nil {
		return nil, err
	}

	taskFacade := getPySpyTaskFacadeForCluster(clients.ClusterName)
	task, err := taskFacade.GetTask(ctx, req.TaskID, constant.TaskTypePySpySample)
	if err != nil {
		return nil, errors.WrapError(err, "failed to get task", errors.CodeDatabaseError)
	}

	if task == nil {
		return nil, errors.NewError().WithCode(errors.RequestDataNotExisted).WithMessage("task not found")
	}

	// Build file info from task ext
	storagePath := database.GetExtString(task, "storage_path")
	storageType := database.GetExtString(task, "storage_type")
	outputFile := database.GetExtString(task, "output_file")
	format := database.GetExtString(task, "format")

	var files []map[string]interface{}
	if storagePath != "" {
		filename := filepath.Base(outputFile)
		if filename == "" || filename == "." {
			filename = fmt.Sprintf("%s.svg", req.TaskID)
		}

		files = append(files, map[string]interface{}{
			"task_id":      req.TaskID,
			"file_name":    filename,
			"format":       format,
			"file_size":    database.GetExtInt(task, "file_size"),
			"storage_type": storageType,
			"storage_path": storagePath,
			"download_url": fmt.Sprintf("/v1/pyspy/file/%s/%s?cluster=%s", req.TaskID, filename, clients.ClusterName),
		})
	}

	return &PySpyTaskFilesResponse{
		TaskID: req.TaskID,
		Files:  files,
	}, nil
}

// Helper functions

func getPySpyTaskFacadeForCluster(clusterName string) *database.WorkloadTaskFacade {
	if clusterName == "" {
		return database.NewWorkloadTaskFacade()
	}
	return database.NewWorkloadTaskFacadeForCluster(clusterName)
}

func pySpyTaskToResponse(task *model.WorkloadTaskState) *PySpyTaskResponse {
	resp := &PySpyTaskResponse{
		TaskID:    task.WorkloadUID,
		Status:    task.Status,
		CreatedAt: task.CreatedAt,
	}

	// Extract fields from ext
	resp.PodUID = database.GetExtString(task, "pod_uid")
	resp.PodName = database.GetExtString(task, "pod_name")
	resp.PodNamespace = database.GetExtString(task, "pod_namespace")
	resp.NodeName = database.GetExtString(task, "target_node_name")
	resp.PID = database.GetExtInt(task, "host_pid")
	resp.Duration = database.GetExtInt(task, "duration")
	resp.Format = database.GetExtString(task, "format")
	resp.OutputFile = database.GetExtString(task, "output_file")
	resp.Error = database.GetExtString(task, "error")

	// Parse file size
	if val, ok := task.Ext["file_size"]; ok {
		switch v := val.(type) {
		case float64:
			resp.FileSize = int64(v)
		case int64:
			resp.FileSize = v
		}
	}

	// Parse timestamps
	if startedAtStr := database.GetExtString(task, "started_at"); startedAtStr != "" {
		if t, err := time.Parse(time.RFC3339, startedAtStr); err == nil {
			resp.StartedAt = &t
		}
	}
	if completedAtStr := database.GetExtString(task, "completed_at"); completedAtStr != "" {
		if t, err := time.Parse(time.RFC3339, completedAtStr); err == nil {
			resp.CompletedAt = &t
		}
	}

	// Set file download path if completed
	if task.Status == constant.TaskStatusCompleted && resp.OutputFile != "" {
		resp.FilePath = fmt.Sprintf("/api/v1/pyspy/file/%s/%s", task.WorkloadUID, getFilenameFromPath(resp.OutputFile))
	}

	return resp
}

// getFilenameFromPath extracts filename from path
func getFilenameFromPath(path string) string {
	for i := len(path) - 1; i >= 0; i-- {
		if path[i] == '/' {
			return path[i+1:]
		}
	}
	return path
}
