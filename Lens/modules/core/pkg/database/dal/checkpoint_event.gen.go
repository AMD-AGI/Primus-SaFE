// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dal

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/AMD-AGI/Primus-SaFE/Lens/core/pkg/database/model"
)

func newCheckpointEvent(db *gorm.DB, opts ...gen.DOOption) checkpointEvent {
	_checkpointEvent := checkpointEvent{}

	_checkpointEvent.checkpointEventDo.UseDB(db, opts...)
	_checkpointEvent.checkpointEventDo.UseModel(&model.CheckpointEvent{})

	tableName := _checkpointEvent.checkpointEventDo.TableName()
	_checkpointEvent.ALL = field.NewAsterisk(tableName)
	_checkpointEvent.ID = field.NewInt64(tableName, "id")
	_checkpointEvent.WorkloadUID = field.NewString(tableName, "workload_uid")
	_checkpointEvent.PodUUID = field.NewString(tableName, "pod_uuid")
	_checkpointEvent.Iteration = field.NewInt32(tableName, "iteration")
	_checkpointEvent.CheckpointPath = field.NewString(tableName, "checkpoint_path")
	_checkpointEvent.EventType = field.NewString(tableName, "event_type")
	_checkpointEvent.StartTime = field.NewTime(tableName, "start_time")
	_checkpointEvent.EndTime = field.NewTime(tableName, "end_time")
	_checkpointEvent.DurationMs = field.NewInt64(tableName, "duration_ms")
	_checkpointEvent.SizeBytes = field.NewInt64(tableName, "size_bytes")
	_checkpointEvent.IsFastCkpt = field.NewBool(tableName, "is_fast_ckpt")
	_checkpointEvent.Metadata = field.NewField(tableName, "metadata")
	_checkpointEvent.CreatedAt = field.NewTime(tableName, "created_at")
	_checkpointEvent.Serial = field.NewInt32(tableName, "serial")
	_checkpointEvent.Status = field.NewString(tableName, "status")

	_checkpointEvent.fillFieldMap()

	return _checkpointEvent
}

type checkpointEvent struct {
	checkpointEventDo

	ALL            field.Asterisk
	ID             field.Int64
	WorkloadUID    field.String // Reference to the workload
	PodUUID        field.String
	Iteration      field.Int32
	CheckpointPath field.String
	EventType      field.String // Type of checkpoint event: start_saving, end_saving, loading
	StartTime      field.Time
	EndTime        field.Time
	DurationMs     field.Int64 // Duration of checkpoint operation in milliseconds
	SizeBytes      field.Int64
	IsFastCkpt     field.Bool  // Whether this is a fast checkpoint
	Metadata       field.Field // Additional metadata extracted from logs
	CreatedAt      field.Time
	Serial         field.Int32
	Status         field.String

	fieldMap map[string]field.Expr
}

func (c checkpointEvent) Table(newTableName string) *checkpointEvent {
	c.checkpointEventDo.UseTable(newTableName)
	return c.updateTableName(newTableName)
}

func (c checkpointEvent) As(alias string) *checkpointEvent {
	c.checkpointEventDo.DO = *(c.checkpointEventDo.As(alias).(*gen.DO))
	return c.updateTableName(alias)
}

func (c *checkpointEvent) updateTableName(table string) *checkpointEvent {
	c.ALL = field.NewAsterisk(table)
	c.ID = field.NewInt64(table, "id")
	c.WorkloadUID = field.NewString(table, "workload_uid")
	c.PodUUID = field.NewString(table, "pod_uuid")
	c.Iteration = field.NewInt32(table, "iteration")
	c.CheckpointPath = field.NewString(table, "checkpoint_path")
	c.EventType = field.NewString(table, "event_type")
	c.StartTime = field.NewTime(table, "start_time")
	c.EndTime = field.NewTime(table, "end_time")
	c.DurationMs = field.NewInt64(table, "duration_ms")
	c.SizeBytes = field.NewInt64(table, "size_bytes")
	c.IsFastCkpt = field.NewBool(table, "is_fast_ckpt")
	c.Metadata = field.NewField(table, "metadata")
	c.CreatedAt = field.NewTime(table, "created_at")
	c.Serial = field.NewInt32(table, "serial")
	c.Status = field.NewString(table, "status")

	c.fillFieldMap()

	return c
}

func (c *checkpointEvent) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := c.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (c *checkpointEvent) fillFieldMap() {
	c.fieldMap = make(map[string]field.Expr, 15)
	c.fieldMap["id"] = c.ID
	c.fieldMap["workload_uid"] = c.WorkloadUID
	c.fieldMap["pod_uuid"] = c.PodUUID
	c.fieldMap["iteration"] = c.Iteration
	c.fieldMap["checkpoint_path"] = c.CheckpointPath
	c.fieldMap["event_type"] = c.EventType
	c.fieldMap["start_time"] = c.StartTime
	c.fieldMap["end_time"] = c.EndTime
	c.fieldMap["duration_ms"] = c.DurationMs
	c.fieldMap["size_bytes"] = c.SizeBytes
	c.fieldMap["is_fast_ckpt"] = c.IsFastCkpt
	c.fieldMap["metadata"] = c.Metadata
	c.fieldMap["created_at"] = c.CreatedAt
	c.fieldMap["serial"] = c.Serial
	c.fieldMap["status"] = c.Status
}

func (c checkpointEvent) clone(db *gorm.DB) checkpointEvent {
	c.checkpointEventDo.ReplaceConnPool(db.Statement.ConnPool)
	return c
}

func (c checkpointEvent) replaceDB(db *gorm.DB) checkpointEvent {
	c.checkpointEventDo.ReplaceDB(db)
	return c
}

type checkpointEventDo struct{ gen.DO }

type ICheckpointEventDo interface {
	gen.SubQuery
	Debug() ICheckpointEventDo
	WithContext(ctx context.Context) ICheckpointEventDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ICheckpointEventDo
	WriteDB() ICheckpointEventDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ICheckpointEventDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ICheckpointEventDo
	Not(conds ...gen.Condition) ICheckpointEventDo
	Or(conds ...gen.Condition) ICheckpointEventDo
	Select(conds ...field.Expr) ICheckpointEventDo
	Where(conds ...gen.Condition) ICheckpointEventDo
	Order(conds ...field.Expr) ICheckpointEventDo
	Distinct(cols ...field.Expr) ICheckpointEventDo
	Omit(cols ...field.Expr) ICheckpointEventDo
	Join(table schema.Tabler, on ...field.Expr) ICheckpointEventDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ICheckpointEventDo
	RightJoin(table schema.Tabler, on ...field.Expr) ICheckpointEventDo
	Group(cols ...field.Expr) ICheckpointEventDo
	Having(conds ...gen.Condition) ICheckpointEventDo
	Limit(limit int) ICheckpointEventDo
	Offset(offset int) ICheckpointEventDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ICheckpointEventDo
	Unscoped() ICheckpointEventDo
	Create(values ...*model.CheckpointEvent) error
	CreateInBatches(values []*model.CheckpointEvent, batchSize int) error
	Save(values ...*model.CheckpointEvent) error
	First() (*model.CheckpointEvent, error)
	Take() (*model.CheckpointEvent, error)
	Last() (*model.CheckpointEvent, error)
	Find() ([]*model.CheckpointEvent, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.CheckpointEvent, err error)
	FindInBatches(result *[]*model.CheckpointEvent, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.CheckpointEvent) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ICheckpointEventDo
	Assign(attrs ...field.AssignExpr) ICheckpointEventDo
	Joins(fields ...field.RelationField) ICheckpointEventDo
	Preload(fields ...field.RelationField) ICheckpointEventDo
	FirstOrInit() (*model.CheckpointEvent, error)
	FirstOrCreate() (*model.CheckpointEvent, error)
	FindByPage(offset int, limit int) (result []*model.CheckpointEvent, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ICheckpointEventDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (c checkpointEventDo) Debug() ICheckpointEventDo {
	return c.withDO(c.DO.Debug())
}

func (c checkpointEventDo) WithContext(ctx context.Context) ICheckpointEventDo {
	return c.withDO(c.DO.WithContext(ctx))
}

func (c checkpointEventDo) ReadDB() ICheckpointEventDo {
	return c.Clauses(dbresolver.Read)
}

func (c checkpointEventDo) WriteDB() ICheckpointEventDo {
	return c.Clauses(dbresolver.Write)
}

func (c checkpointEventDo) Session(config *gorm.Session) ICheckpointEventDo {
	return c.withDO(c.DO.Session(config))
}

func (c checkpointEventDo) Clauses(conds ...clause.Expression) ICheckpointEventDo {
	return c.withDO(c.DO.Clauses(conds...))
}

func (c checkpointEventDo) Returning(value interface{}, columns ...string) ICheckpointEventDo {
	return c.withDO(c.DO.Returning(value, columns...))
}

func (c checkpointEventDo) Not(conds ...gen.Condition) ICheckpointEventDo {
	return c.withDO(c.DO.Not(conds...))
}

func (c checkpointEventDo) Or(conds ...gen.Condition) ICheckpointEventDo {
	return c.withDO(c.DO.Or(conds...))
}

func (c checkpointEventDo) Select(conds ...field.Expr) ICheckpointEventDo {
	return c.withDO(c.DO.Select(conds...))
}

func (c checkpointEventDo) Where(conds ...gen.Condition) ICheckpointEventDo {
	return c.withDO(c.DO.Where(conds...))
}

func (c checkpointEventDo) Order(conds ...field.Expr) ICheckpointEventDo {
	return c.withDO(c.DO.Order(conds...))
}

func (c checkpointEventDo) Distinct(cols ...field.Expr) ICheckpointEventDo {
	return c.withDO(c.DO.Distinct(cols...))
}

func (c checkpointEventDo) Omit(cols ...field.Expr) ICheckpointEventDo {
	return c.withDO(c.DO.Omit(cols...))
}

func (c checkpointEventDo) Join(table schema.Tabler, on ...field.Expr) ICheckpointEventDo {
	return c.withDO(c.DO.Join(table, on...))
}

func (c checkpointEventDo) LeftJoin(table schema.Tabler, on ...field.Expr) ICheckpointEventDo {
	return c.withDO(c.DO.LeftJoin(table, on...))
}

func (c checkpointEventDo) RightJoin(table schema.Tabler, on ...field.Expr) ICheckpointEventDo {
	return c.withDO(c.DO.RightJoin(table, on...))
}

func (c checkpointEventDo) Group(cols ...field.Expr) ICheckpointEventDo {
	return c.withDO(c.DO.Group(cols...))
}

func (c checkpointEventDo) Having(conds ...gen.Condition) ICheckpointEventDo {
	return c.withDO(c.DO.Having(conds...))
}

func (c checkpointEventDo) Limit(limit int) ICheckpointEventDo {
	return c.withDO(c.DO.Limit(limit))
}

func (c checkpointEventDo) Offset(offset int) ICheckpointEventDo {
	return c.withDO(c.DO.Offset(offset))
}

func (c checkpointEventDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ICheckpointEventDo {
	return c.withDO(c.DO.Scopes(funcs...))
}

func (c checkpointEventDo) Unscoped() ICheckpointEventDo {
	return c.withDO(c.DO.Unscoped())
}

func (c checkpointEventDo) Create(values ...*model.CheckpointEvent) error {
	if len(values) == 0 {
		return nil
	}
	return c.DO.Create(values)
}

func (c checkpointEventDo) CreateInBatches(values []*model.CheckpointEvent, batchSize int) error {
	return c.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (c checkpointEventDo) Save(values ...*model.CheckpointEvent) error {
	if len(values) == 0 {
		return nil
	}
	return c.DO.Save(values)
}

func (c checkpointEventDo) First() (*model.CheckpointEvent, error) {
	if result, err := c.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.CheckpointEvent), nil
	}
}

func (c checkpointEventDo) Take() (*model.CheckpointEvent, error) {
	if result, err := c.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.CheckpointEvent), nil
	}
}

func (c checkpointEventDo) Last() (*model.CheckpointEvent, error) {
	if result, err := c.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.CheckpointEvent), nil
	}
}

func (c checkpointEventDo) Find() ([]*model.CheckpointEvent, error) {
	result, err := c.DO.Find()
	return result.([]*model.CheckpointEvent), err
}

func (c checkpointEventDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.CheckpointEvent, err error) {
	buf := make([]*model.CheckpointEvent, 0, batchSize)
	err = c.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (c checkpointEventDo) FindInBatches(result *[]*model.CheckpointEvent, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return c.DO.FindInBatches(result, batchSize, fc)
}

func (c checkpointEventDo) Attrs(attrs ...field.AssignExpr) ICheckpointEventDo {
	return c.withDO(c.DO.Attrs(attrs...))
}

func (c checkpointEventDo) Assign(attrs ...field.AssignExpr) ICheckpointEventDo {
	return c.withDO(c.DO.Assign(attrs...))
}

func (c checkpointEventDo) Joins(fields ...field.RelationField) ICheckpointEventDo {
	for _, _f := range fields {
		c = *c.withDO(c.DO.Joins(_f))
	}
	return &c
}

func (c checkpointEventDo) Preload(fields ...field.RelationField) ICheckpointEventDo {
	for _, _f := range fields {
		c = *c.withDO(c.DO.Preload(_f))
	}
	return &c
}

func (c checkpointEventDo) FirstOrInit() (*model.CheckpointEvent, error) {
	if result, err := c.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.CheckpointEvent), nil
	}
}

func (c checkpointEventDo) FirstOrCreate() (*model.CheckpointEvent, error) {
	if result, err := c.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.CheckpointEvent), nil
	}
}

func (c checkpointEventDo) FindByPage(offset int, limit int) (result []*model.CheckpointEvent, count int64, err error) {
	result, err = c.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = c.Offset(-1).Limit(-1).Count()
	return
}

func (c checkpointEventDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = c.Count()
	if err != nil {
		return
	}

	err = c.Offset(offset).Limit(limit).Scan(result)
	return
}

func (c checkpointEventDo) Scan(result interface{}) (err error) {
	return c.DO.Scan(result)
}

func (c checkpointEventDo) Delete(models ...*model.CheckpointEvent) (result gen.ResultInfo, err error) {
	return c.DO.Delete(models)
}

func (c *checkpointEventDo) withDO(do gen.Dao) *checkpointEventDo {
	c.DO = *do.(*gen.DO)
	return c
}
