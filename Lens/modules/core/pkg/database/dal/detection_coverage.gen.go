// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dal

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/AMD-AGI/Primus-SaFE/Lens/core/pkg/database/model"
)

func newDetectionCoverage(db *gorm.DB, opts ...gen.DOOption) detectionCoverage {
	_detectionCoverage := detectionCoverage{}

	_detectionCoverage.detectionCoverageDo.UseDB(db, opts...)
	_detectionCoverage.detectionCoverageDo.UseModel(&model.DetectionCoverage{})

	tableName := _detectionCoverage.detectionCoverageDo.TableName()
	_detectionCoverage.ALL = field.NewAsterisk(tableName)
	_detectionCoverage.ID = field.NewInt64(tableName, "id")
	_detectionCoverage.WorkloadUID = field.NewString(tableName, "workload_uid")
	_detectionCoverage.Source = field.NewString(tableName, "source")
	_detectionCoverage.Status = field.NewString(tableName, "status")
	_detectionCoverage.AttemptCount = field.NewInt32(tableName, "attempt_count")
	_detectionCoverage.LastAttemptAt = field.NewTime(tableName, "last_attempt_at")
	_detectionCoverage.LastSuccessAt = field.NewTime(tableName, "last_success_at")
	_detectionCoverage.LastError = field.NewString(tableName, "last_error")
	_detectionCoverage.CoveredFrom = field.NewTime(tableName, "covered_from")
	_detectionCoverage.CoveredTo = field.NewTime(tableName, "covered_to")
	_detectionCoverage.PendingFrom = field.NewTime(tableName, "pending_from")
	_detectionCoverage.PendingTo = field.NewTime(tableName, "pending_to")
	_detectionCoverage.LogAvailableFrom = field.NewTime(tableName, "log_available_from")
	_detectionCoverage.LogAvailableTo = field.NewTime(tableName, "log_available_to")
	_detectionCoverage.EvidenceCount = field.NewInt32(tableName, "evidence_count")
	_detectionCoverage.Ext = field.NewField(tableName, "ext")
	_detectionCoverage.CreatedAt = field.NewTime(tableName, "created_at")
	_detectionCoverage.UpdatedAt = field.NewTime(tableName, "updated_at")

	_detectionCoverage.fillFieldMap()

	return _detectionCoverage
}

type detectionCoverage struct {
	detectionCoverageDo detectionCoverageDo

	ALL              field.Asterisk
	ID               field.Int64
	WorkloadUID      field.String // Workload unique identifier
	Source           field.String // Evidence source: process, log, image, label, wandb, import
	Status           field.String // Collection status: pending, collecting, collected, failed, not_applicable
	AttemptCount     field.Int32  // Number of collection attempts
	LastAttemptAt    field.Time
	LastSuccessAt    field.Time
	LastError        field.String
	CoveredFrom      field.Time  // Start of time range that has been scanned (for log source)
	CoveredTo        field.Time  // End of time range that has been scanned (for log source)
	PendingFrom      field.Time  // Start of time range pending backfill (for log source)
	PendingTo        field.Time  // End of time range pending backfill (for log source)
	LogAvailableFrom field.Time  // Earliest log timestamp from telemetry-processor
	LogAvailableTo   field.Time  // Latest log timestamp from telemetry-processor
	EvidenceCount    field.Int32 // Number of evidence records collected from this source
	Ext              field.Field
	CreatedAt        field.Time
	UpdatedAt        field.Time

	fieldMap map[string]field.Expr
}

func (d detectionCoverage) Table(newTableName string) *detectionCoverage {
	d.detectionCoverageDo.UseTable(newTableName)
	return d.updateTableName(newTableName)
}

func (d detectionCoverage) As(alias string) *detectionCoverage {
	d.detectionCoverageDo.DO = *(d.detectionCoverageDo.As(alias).(*gen.DO))
	return d.updateTableName(alias)
}

func (d *detectionCoverage) updateTableName(table string) *detectionCoverage {
	d.ALL = field.NewAsterisk(table)
	d.ID = field.NewInt64(table, "id")
	d.WorkloadUID = field.NewString(table, "workload_uid")
	d.Source = field.NewString(table, "source")
	d.Status = field.NewString(table, "status")
	d.AttemptCount = field.NewInt32(table, "attempt_count")
	d.LastAttemptAt = field.NewTime(table, "last_attempt_at")
	d.LastSuccessAt = field.NewTime(table, "last_success_at")
	d.LastError = field.NewString(table, "last_error")
	d.CoveredFrom = field.NewTime(table, "covered_from")
	d.CoveredTo = field.NewTime(table, "covered_to")
	d.PendingFrom = field.NewTime(table, "pending_from")
	d.PendingTo = field.NewTime(table, "pending_to")
	d.LogAvailableFrom = field.NewTime(table, "log_available_from")
	d.LogAvailableTo = field.NewTime(table, "log_available_to")
	d.EvidenceCount = field.NewInt32(table, "evidence_count")
	d.Ext = field.NewField(table, "ext")
	d.CreatedAt = field.NewTime(table, "created_at")
	d.UpdatedAt = field.NewTime(table, "updated_at")

	d.fillFieldMap()

	return d
}

func (d *detectionCoverage) WithContext(ctx context.Context) *detectionCoverageDo {
	return d.detectionCoverageDo.WithContext(ctx)
}

func (d detectionCoverage) TableName() string { return d.detectionCoverageDo.TableName() }

func (d detectionCoverage) Alias() string { return d.detectionCoverageDo.Alias() }

func (d detectionCoverage) Columns(cols ...field.Expr) gen.Columns {
	return d.detectionCoverageDo.Columns(cols...)
}

func (d *detectionCoverage) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := d.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (d *detectionCoverage) fillFieldMap() {
	d.fieldMap = make(map[string]field.Expr, 18)
	d.fieldMap["id"] = d.ID
	d.fieldMap["workload_uid"] = d.WorkloadUID
	d.fieldMap["source"] = d.Source
	d.fieldMap["status"] = d.Status
	d.fieldMap["attempt_count"] = d.AttemptCount
	d.fieldMap["last_attempt_at"] = d.LastAttemptAt
	d.fieldMap["last_success_at"] = d.LastSuccessAt
	d.fieldMap["last_error"] = d.LastError
	d.fieldMap["covered_from"] = d.CoveredFrom
	d.fieldMap["covered_to"] = d.CoveredTo
	d.fieldMap["pending_from"] = d.PendingFrom
	d.fieldMap["pending_to"] = d.PendingTo
	d.fieldMap["log_available_from"] = d.LogAvailableFrom
	d.fieldMap["log_available_to"] = d.LogAvailableTo
	d.fieldMap["evidence_count"] = d.EvidenceCount
	d.fieldMap["ext"] = d.Ext
	d.fieldMap["created_at"] = d.CreatedAt
	d.fieldMap["updated_at"] = d.UpdatedAt
}

func (d detectionCoverage) clone(db *gorm.DB) detectionCoverage {
	d.detectionCoverageDo.ReplaceConnPool(db.Statement.ConnPool)
	return d
}

func (d detectionCoverage) replaceDB(db *gorm.DB) detectionCoverage {
	d.detectionCoverageDo.ReplaceDB(db)
	return d
}

type detectionCoverageDo struct{ gen.DO }

func (d detectionCoverageDo) Debug() *detectionCoverageDo {
	return d.withDO(d.DO.Debug())
}

func (d detectionCoverageDo) WithContext(ctx context.Context) *detectionCoverageDo {
	return d.withDO(d.DO.WithContext(ctx))
}

func (d detectionCoverageDo) ReadDB() *detectionCoverageDo {
	return d.Clauses(dbresolver.Read)
}

func (d detectionCoverageDo) WriteDB() *detectionCoverageDo {
	return d.Clauses(dbresolver.Write)
}

func (d detectionCoverageDo) Session(config *gorm.Session) *detectionCoverageDo {
	return d.withDO(d.DO.Session(config))
}

func (d detectionCoverageDo) Clauses(conds ...clause.Expression) *detectionCoverageDo {
	return d.withDO(d.DO.Clauses(conds...))
}

func (d detectionCoverageDo) Returning(value interface{}, columns ...string) *detectionCoverageDo {
	return d.withDO(d.DO.Returning(value, columns...))
}

func (d detectionCoverageDo) Not(conds ...gen.Condition) *detectionCoverageDo {
	return d.withDO(d.DO.Not(conds...))
}

func (d detectionCoverageDo) Or(conds ...gen.Condition) *detectionCoverageDo {
	return d.withDO(d.DO.Or(conds...))
}

func (d detectionCoverageDo) Select(conds ...field.Expr) *detectionCoverageDo {
	return d.withDO(d.DO.Select(conds...))
}

func (d detectionCoverageDo) Where(conds ...gen.Condition) *detectionCoverageDo {
	return d.withDO(d.DO.Where(conds...))
}

func (d detectionCoverageDo) Order(conds ...field.Expr) *detectionCoverageDo {
	return d.withDO(d.DO.Order(conds...))
}

func (d detectionCoverageDo) Distinct(cols ...field.Expr) *detectionCoverageDo {
	return d.withDO(d.DO.Distinct(cols...))
}

func (d detectionCoverageDo) Omit(cols ...field.Expr) *detectionCoverageDo {
	return d.withDO(d.DO.Omit(cols...))
}

func (d detectionCoverageDo) Join(table schema.Tabler, on ...field.Expr) *detectionCoverageDo {
	return d.withDO(d.DO.Join(table, on...))
}

func (d detectionCoverageDo) LeftJoin(table schema.Tabler, on ...field.Expr) *detectionCoverageDo {
	return d.withDO(d.DO.LeftJoin(table, on...))
}

func (d detectionCoverageDo) RightJoin(table schema.Tabler, on ...field.Expr) *detectionCoverageDo {
	return d.withDO(d.DO.RightJoin(table, on...))
}

func (d detectionCoverageDo) Group(cols ...field.Expr) *detectionCoverageDo {
	return d.withDO(d.DO.Group(cols...))
}

func (d detectionCoverageDo) Having(conds ...gen.Condition) *detectionCoverageDo {
	return d.withDO(d.DO.Having(conds...))
}

func (d detectionCoverageDo) Limit(limit int) *detectionCoverageDo {
	return d.withDO(d.DO.Limit(limit))
}

func (d detectionCoverageDo) Offset(offset int) *detectionCoverageDo {
	return d.withDO(d.DO.Offset(offset))
}

func (d detectionCoverageDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *detectionCoverageDo {
	return d.withDO(d.DO.Scopes(funcs...))
}

func (d detectionCoverageDo) Unscoped() *detectionCoverageDo {
	return d.withDO(d.DO.Unscoped())
}

func (d detectionCoverageDo) Create(values ...*model.DetectionCoverage) error {
	if len(values) == 0 {
		return nil
	}
	return d.DO.Create(values)
}

func (d detectionCoverageDo) CreateInBatches(values []*model.DetectionCoverage, batchSize int) error {
	return d.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (d detectionCoverageDo) Save(values ...*model.DetectionCoverage) error {
	if len(values) == 0 {
		return nil
	}
	return d.DO.Save(values)
}

func (d detectionCoverageDo) First() (*model.DetectionCoverage, error) {
	if result, err := d.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.DetectionCoverage), nil
	}
}

func (d detectionCoverageDo) Take() (*model.DetectionCoverage, error) {
	if result, err := d.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.DetectionCoverage), nil
	}
}

func (d detectionCoverageDo) Last() (*model.DetectionCoverage, error) {
	if result, err := d.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.DetectionCoverage), nil
	}
}

func (d detectionCoverageDo) Find() ([]*model.DetectionCoverage, error) {
	result, err := d.DO.Find()
	return result.([]*model.DetectionCoverage), err
}

func (d detectionCoverageDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.DetectionCoverage, err error) {
	buf := make([]*model.DetectionCoverage, 0, batchSize)
	err = d.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (d detectionCoverageDo) FindInBatches(result *[]*model.DetectionCoverage, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return d.DO.FindInBatches(result, batchSize, fc)
}

func (d detectionCoverageDo) Attrs(attrs ...field.AssignExpr) *detectionCoverageDo {
	return d.withDO(d.DO.Attrs(attrs...))
}

func (d detectionCoverageDo) Assign(attrs ...field.AssignExpr) *detectionCoverageDo {
	return d.withDO(d.DO.Assign(attrs...))
}

func (d detectionCoverageDo) Joins(fields ...field.RelationField) *detectionCoverageDo {
	for _, _f := range fields {
		d = *d.withDO(d.DO.Joins(_f))
	}
	return &d
}

func (d detectionCoverageDo) Preload(fields ...field.RelationField) *detectionCoverageDo {
	for _, _f := range fields {
		d = *d.withDO(d.DO.Preload(_f))
	}
	return &d
}

func (d detectionCoverageDo) FirstOrInit() (*model.DetectionCoverage, error) {
	if result, err := d.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.DetectionCoverage), nil
	}
}

func (d detectionCoverageDo) FirstOrCreate() (*model.DetectionCoverage, error) {
	if result, err := d.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.DetectionCoverage), nil
	}
}

func (d detectionCoverageDo) FindByPage(offset int, limit int) (result []*model.DetectionCoverage, count int64, err error) {
	result, err = d.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = d.Offset(-1).Limit(-1).Count()
	return
}

func (d detectionCoverageDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = d.Count()
	if err != nil {
		return
	}

	err = d.Offset(offset).Limit(limit).Scan(result)
	return
}

func (d detectionCoverageDo) Scan(result interface{}) (err error) {
	return d.DO.Scan(result)
}

func (d detectionCoverageDo) Delete(models ...*model.DetectionCoverage) (result gen.ResultInfo, err error) {
	return d.DO.Delete(models)
}

func (d *detectionCoverageDo) withDO(do gen.Dao) *detectionCoverageDo {
	d.DO = *do.(*gen.DO)
	return d
}
