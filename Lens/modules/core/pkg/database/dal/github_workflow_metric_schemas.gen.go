// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dal

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/AMD-AGI/Primus-SaFE/Lens/core/pkg/database/model"
)

func newGithubWorkflowMetricSchemas(db *gorm.DB, opts ...gen.DOOption) githubWorkflowMetricSchemas {
	_githubWorkflowMetricSchemas := githubWorkflowMetricSchemas{}

	_githubWorkflowMetricSchemas.githubWorkflowMetricSchemasDo.UseDB(db, opts...)
	_githubWorkflowMetricSchemas.githubWorkflowMetricSchemasDo.UseModel(&model.GithubWorkflowMetricSchemas{})

	tableName := _githubWorkflowMetricSchemas.githubWorkflowMetricSchemasDo.TableName()
	_githubWorkflowMetricSchemas.ALL = field.NewAsterisk(tableName)
	_githubWorkflowMetricSchemas.ID = field.NewInt64(tableName, "id")
	_githubWorkflowMetricSchemas.ConfigID = field.NewInt64(tableName, "config_id")
	_githubWorkflowMetricSchemas.Name = field.NewString(tableName, "name")
	_githubWorkflowMetricSchemas.Version = field.NewInt32(tableName, "version")
	_githubWorkflowMetricSchemas.Fields = field.NewField(tableName, "fields")
	_githubWorkflowMetricSchemas.DimensionFields = field.NewField(tableName, "dimension_fields")
	_githubWorkflowMetricSchemas.MetricFields = field.NewField(tableName, "metric_fields")
	_githubWorkflowMetricSchemas.IsActive = field.NewBool(tableName, "is_active")
	_githubWorkflowMetricSchemas.GeneratedBy = field.NewString(tableName, "generated_by")
	_githubWorkflowMetricSchemas.GenerationSampleFile = field.NewString(tableName, "generation_sample_file")
	_githubWorkflowMetricSchemas.CreatedAt = field.NewTime(tableName, "created_at")
	_githubWorkflowMetricSchemas.UpdatedAt = field.NewTime(tableName, "updated_at")
	_githubWorkflowMetricSchemas.SchemaHash = field.NewString(tableName, "schema_hash")
	_githubWorkflowMetricSchemas.IsWideTable = field.NewBool(tableName, "is_wide_table")
	_githubWorkflowMetricSchemas.DateColumns = field.NewField(tableName, "date_columns")
	_githubWorkflowMetricSchemas.RecordCount = field.NewInt64(tableName, "record_count")
	_githubWorkflowMetricSchemas.FirstSeenAt = field.NewTime(tableName, "first_seen_at")
	_githubWorkflowMetricSchemas.LastSeenAt = field.NewTime(tableName, "last_seen_at")
	_githubWorkflowMetricSchemas.TimeField = field.NewString(tableName, "time_field")
	_githubWorkflowMetricSchemas.ColumnDefinitions = field.NewField(tableName, "column_definitions")
	_githubWorkflowMetricSchemas.DateColumnPattern = field.NewString(tableName, "date_column_pattern")
	_githubWorkflowMetricSchemas.DateColumnConfig = field.NewField(tableName, "date_column_config")

	_githubWorkflowMetricSchemas.fillFieldMap()

	return _githubWorkflowMetricSchemas
}

type githubWorkflowMetricSchemas struct {
	githubWorkflowMetricSchemasDo githubWorkflowMetricSchemasDo

	ALL                  field.Asterisk
	ID                   field.Int64
	ConfigID             field.Int64
	Name                 field.String
	Version              field.Int32
	Fields               field.Field
	DimensionFields      field.Field
	MetricFields         field.Field
	IsActive             field.Bool
	GeneratedBy          field.String
	GenerationSampleFile field.String
	CreatedAt            field.Time
	UpdatedAt            field.Time
	SchemaHash           field.String
	IsWideTable          field.Bool
	DateColumns          field.Field
	RecordCount          field.Int64
	FirstSeenAt          field.Time
	LastSeenAt           field.Time
	TimeField            field.String
	ColumnDefinitions    field.Field
	DateColumnPattern    field.String
	DateColumnConfig     field.Field

	fieldMap map[string]field.Expr
}

func (g githubWorkflowMetricSchemas) Table(newTableName string) *githubWorkflowMetricSchemas {
	g.githubWorkflowMetricSchemasDo.UseTable(newTableName)
	return g.updateTableName(newTableName)
}

func (g githubWorkflowMetricSchemas) As(alias string) *githubWorkflowMetricSchemas {
	g.githubWorkflowMetricSchemasDo.DO = *(g.githubWorkflowMetricSchemasDo.As(alias).(*gen.DO))
	return g.updateTableName(alias)
}

func (g *githubWorkflowMetricSchemas) updateTableName(table string) *githubWorkflowMetricSchemas {
	g.ALL = field.NewAsterisk(table)
	g.ID = field.NewInt64(table, "id")
	g.ConfigID = field.NewInt64(table, "config_id")
	g.Name = field.NewString(table, "name")
	g.Version = field.NewInt32(table, "version")
	g.Fields = field.NewField(table, "fields")
	g.DimensionFields = field.NewField(table, "dimension_fields")
	g.MetricFields = field.NewField(table, "metric_fields")
	g.IsActive = field.NewBool(table, "is_active")
	g.GeneratedBy = field.NewString(table, "generated_by")
	g.GenerationSampleFile = field.NewString(table, "generation_sample_file")
	g.CreatedAt = field.NewTime(table, "created_at")
	g.UpdatedAt = field.NewTime(table, "updated_at")
	g.SchemaHash = field.NewString(table, "schema_hash")
	g.IsWideTable = field.NewBool(table, "is_wide_table")
	g.DateColumns = field.NewField(table, "date_columns")
	g.RecordCount = field.NewInt64(table, "record_count")
	g.FirstSeenAt = field.NewTime(table, "first_seen_at")
	g.LastSeenAt = field.NewTime(table, "last_seen_at")
	g.TimeField = field.NewString(table, "time_field")
	g.ColumnDefinitions = field.NewField(table, "column_definitions")
	g.DateColumnPattern = field.NewString(table, "date_column_pattern")
	g.DateColumnConfig = field.NewField(table, "date_column_config")

	g.fillFieldMap()

	return g
}

func (g *githubWorkflowMetricSchemas) WithContext(ctx context.Context) *githubWorkflowMetricSchemasDo {
	return g.githubWorkflowMetricSchemasDo.WithContext(ctx)
}

func (g githubWorkflowMetricSchemas) TableName() string {
	return g.githubWorkflowMetricSchemasDo.TableName()
}

func (g githubWorkflowMetricSchemas) Alias() string { return g.githubWorkflowMetricSchemasDo.Alias() }

func (g githubWorkflowMetricSchemas) Columns(cols ...field.Expr) gen.Columns {
	return g.githubWorkflowMetricSchemasDo.Columns(cols...)
}

func (g *githubWorkflowMetricSchemas) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := g.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (g *githubWorkflowMetricSchemas) fillFieldMap() {
	g.fieldMap = make(map[string]field.Expr, 22)
	g.fieldMap["id"] = g.ID
	g.fieldMap["config_id"] = g.ConfigID
	g.fieldMap["name"] = g.Name
	g.fieldMap["version"] = g.Version
	g.fieldMap["fields"] = g.Fields
	g.fieldMap["dimension_fields"] = g.DimensionFields
	g.fieldMap["metric_fields"] = g.MetricFields
	g.fieldMap["is_active"] = g.IsActive
	g.fieldMap["generated_by"] = g.GeneratedBy
	g.fieldMap["generation_sample_file"] = g.GenerationSampleFile
	g.fieldMap["created_at"] = g.CreatedAt
	g.fieldMap["updated_at"] = g.UpdatedAt
	g.fieldMap["schema_hash"] = g.SchemaHash
	g.fieldMap["is_wide_table"] = g.IsWideTable
	g.fieldMap["date_columns"] = g.DateColumns
	g.fieldMap["record_count"] = g.RecordCount
	g.fieldMap["first_seen_at"] = g.FirstSeenAt
	g.fieldMap["last_seen_at"] = g.LastSeenAt
	g.fieldMap["time_field"] = g.TimeField
	g.fieldMap["column_definitions"] = g.ColumnDefinitions
	g.fieldMap["date_column_pattern"] = g.DateColumnPattern
	g.fieldMap["date_column_config"] = g.DateColumnConfig
}

func (g githubWorkflowMetricSchemas) clone(db *gorm.DB) githubWorkflowMetricSchemas {
	g.githubWorkflowMetricSchemasDo.ReplaceConnPool(db.Statement.ConnPool)
	return g
}

func (g githubWorkflowMetricSchemas) replaceDB(db *gorm.DB) githubWorkflowMetricSchemas {
	g.githubWorkflowMetricSchemasDo.ReplaceDB(db)
	return g
}

type githubWorkflowMetricSchemasDo struct{ gen.DO }

func (g githubWorkflowMetricSchemasDo) Debug() *githubWorkflowMetricSchemasDo {
	return g.withDO(g.DO.Debug())
}

func (g githubWorkflowMetricSchemasDo) WithContext(ctx context.Context) *githubWorkflowMetricSchemasDo {
	return g.withDO(g.DO.WithContext(ctx))
}

func (g githubWorkflowMetricSchemasDo) ReadDB() *githubWorkflowMetricSchemasDo {
	return g.Clauses(dbresolver.Read)
}

func (g githubWorkflowMetricSchemasDo) WriteDB() *githubWorkflowMetricSchemasDo {
	return g.Clauses(dbresolver.Write)
}

func (g githubWorkflowMetricSchemasDo) Session(config *gorm.Session) *githubWorkflowMetricSchemasDo {
	return g.withDO(g.DO.Session(config))
}

func (g githubWorkflowMetricSchemasDo) Clauses(conds ...clause.Expression) *githubWorkflowMetricSchemasDo {
	return g.withDO(g.DO.Clauses(conds...))
}

func (g githubWorkflowMetricSchemasDo) Returning(value interface{}, columns ...string) *githubWorkflowMetricSchemasDo {
	return g.withDO(g.DO.Returning(value, columns...))
}

func (g githubWorkflowMetricSchemasDo) Not(conds ...gen.Condition) *githubWorkflowMetricSchemasDo {
	return g.withDO(g.DO.Not(conds...))
}

func (g githubWorkflowMetricSchemasDo) Or(conds ...gen.Condition) *githubWorkflowMetricSchemasDo {
	return g.withDO(g.DO.Or(conds...))
}

func (g githubWorkflowMetricSchemasDo) Select(conds ...field.Expr) *githubWorkflowMetricSchemasDo {
	return g.withDO(g.DO.Select(conds...))
}

func (g githubWorkflowMetricSchemasDo) Where(conds ...gen.Condition) *githubWorkflowMetricSchemasDo {
	return g.withDO(g.DO.Where(conds...))
}

func (g githubWorkflowMetricSchemasDo) Order(conds ...field.Expr) *githubWorkflowMetricSchemasDo {
	return g.withDO(g.DO.Order(conds...))
}

func (g githubWorkflowMetricSchemasDo) Distinct(cols ...field.Expr) *githubWorkflowMetricSchemasDo {
	return g.withDO(g.DO.Distinct(cols...))
}

func (g githubWorkflowMetricSchemasDo) Omit(cols ...field.Expr) *githubWorkflowMetricSchemasDo {
	return g.withDO(g.DO.Omit(cols...))
}

func (g githubWorkflowMetricSchemasDo) Join(table schema.Tabler, on ...field.Expr) *githubWorkflowMetricSchemasDo {
	return g.withDO(g.DO.Join(table, on...))
}

func (g githubWorkflowMetricSchemasDo) LeftJoin(table schema.Tabler, on ...field.Expr) *githubWorkflowMetricSchemasDo {
	return g.withDO(g.DO.LeftJoin(table, on...))
}

func (g githubWorkflowMetricSchemasDo) RightJoin(table schema.Tabler, on ...field.Expr) *githubWorkflowMetricSchemasDo {
	return g.withDO(g.DO.RightJoin(table, on...))
}

func (g githubWorkflowMetricSchemasDo) Group(cols ...field.Expr) *githubWorkflowMetricSchemasDo {
	return g.withDO(g.DO.Group(cols...))
}

func (g githubWorkflowMetricSchemasDo) Having(conds ...gen.Condition) *githubWorkflowMetricSchemasDo {
	return g.withDO(g.DO.Having(conds...))
}

func (g githubWorkflowMetricSchemasDo) Limit(limit int) *githubWorkflowMetricSchemasDo {
	return g.withDO(g.DO.Limit(limit))
}

func (g githubWorkflowMetricSchemasDo) Offset(offset int) *githubWorkflowMetricSchemasDo {
	return g.withDO(g.DO.Offset(offset))
}

func (g githubWorkflowMetricSchemasDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *githubWorkflowMetricSchemasDo {
	return g.withDO(g.DO.Scopes(funcs...))
}

func (g githubWorkflowMetricSchemasDo) Unscoped() *githubWorkflowMetricSchemasDo {
	return g.withDO(g.DO.Unscoped())
}

func (g githubWorkflowMetricSchemasDo) Create(values ...*model.GithubWorkflowMetricSchemas) error {
	if len(values) == 0 {
		return nil
	}
	return g.DO.Create(values)
}

func (g githubWorkflowMetricSchemasDo) CreateInBatches(values []*model.GithubWorkflowMetricSchemas, batchSize int) error {
	return g.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (g githubWorkflowMetricSchemasDo) Save(values ...*model.GithubWorkflowMetricSchemas) error {
	if len(values) == 0 {
		return nil
	}
	return g.DO.Save(values)
}

func (g githubWorkflowMetricSchemasDo) First() (*model.GithubWorkflowMetricSchemas, error) {
	if result, err := g.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.GithubWorkflowMetricSchemas), nil
	}
}

func (g githubWorkflowMetricSchemasDo) Take() (*model.GithubWorkflowMetricSchemas, error) {
	if result, err := g.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.GithubWorkflowMetricSchemas), nil
	}
}

func (g githubWorkflowMetricSchemasDo) Last() (*model.GithubWorkflowMetricSchemas, error) {
	if result, err := g.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.GithubWorkflowMetricSchemas), nil
	}
}

func (g githubWorkflowMetricSchemasDo) Find() ([]*model.GithubWorkflowMetricSchemas, error) {
	result, err := g.DO.Find()
	return result.([]*model.GithubWorkflowMetricSchemas), err
}

func (g githubWorkflowMetricSchemasDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.GithubWorkflowMetricSchemas, err error) {
	buf := make([]*model.GithubWorkflowMetricSchemas, 0, batchSize)
	err = g.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (g githubWorkflowMetricSchemasDo) FindInBatches(result *[]*model.GithubWorkflowMetricSchemas, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return g.DO.FindInBatches(result, batchSize, fc)
}

func (g githubWorkflowMetricSchemasDo) Attrs(attrs ...field.AssignExpr) *githubWorkflowMetricSchemasDo {
	return g.withDO(g.DO.Attrs(attrs...))
}

func (g githubWorkflowMetricSchemasDo) Assign(attrs ...field.AssignExpr) *githubWorkflowMetricSchemasDo {
	return g.withDO(g.DO.Assign(attrs...))
}

func (g githubWorkflowMetricSchemasDo) Joins(fields ...field.RelationField) *githubWorkflowMetricSchemasDo {
	for _, _f := range fields {
		g = *g.withDO(g.DO.Joins(_f))
	}
	return &g
}

func (g githubWorkflowMetricSchemasDo) Preload(fields ...field.RelationField) *githubWorkflowMetricSchemasDo {
	for _, _f := range fields {
		g = *g.withDO(g.DO.Preload(_f))
	}
	return &g
}

func (g githubWorkflowMetricSchemasDo) FirstOrInit() (*model.GithubWorkflowMetricSchemas, error) {
	if result, err := g.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.GithubWorkflowMetricSchemas), nil
	}
}

func (g githubWorkflowMetricSchemasDo) FirstOrCreate() (*model.GithubWorkflowMetricSchemas, error) {
	if result, err := g.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.GithubWorkflowMetricSchemas), nil
	}
}

func (g githubWorkflowMetricSchemasDo) FindByPage(offset int, limit int) (result []*model.GithubWorkflowMetricSchemas, count int64, err error) {
	result, err = g.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = g.Offset(-1).Limit(-1).Count()
	return
}

func (g githubWorkflowMetricSchemasDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = g.Count()
	if err != nil {
		return
	}

	err = g.Offset(offset).Limit(limit).Scan(result)
	return
}

func (g githubWorkflowMetricSchemasDo) Scan(result interface{}) (err error) {
	return g.DO.Scan(result)
}

func (g githubWorkflowMetricSchemasDo) Delete(models ...*model.GithubWorkflowMetricSchemas) (result gen.ResultInfo, err error) {
	return g.DO.Delete(models)
}

func (g *githubWorkflowMetricSchemasDo) withDO(do gen.Dao) *githubWorkflowMetricSchemasDo {
	g.DO = *do.(*gen.DO)
	return g
}
