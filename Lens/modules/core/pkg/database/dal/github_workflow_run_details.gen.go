// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dal

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/AMD-AGI/Primus-SaFE/Lens/core/pkg/database/model"
)

func newGithubWorkflowRunDetails(db *gorm.DB, opts ...gen.DOOption) githubWorkflowRunDetails {
	_githubWorkflowRunDetails := githubWorkflowRunDetails{}

	_githubWorkflowRunDetails.githubWorkflowRunDetailsDo.UseDB(db, opts...)
	_githubWorkflowRunDetails.githubWorkflowRunDetailsDo.UseModel(&model.GithubWorkflowRunDetails{})

	tableName := _githubWorkflowRunDetails.githubWorkflowRunDetailsDo.TableName()
	_githubWorkflowRunDetails.ALL = field.NewAsterisk(tableName)
	_githubWorkflowRunDetails.ID = field.NewInt64(tableName, "id")
	_githubWorkflowRunDetails.RunID = field.NewInt64(tableName, "run_id")
	_githubWorkflowRunDetails.GithubRunID = field.NewInt64(tableName, "github_run_id")
	_githubWorkflowRunDetails.GithubRunNumber = field.NewInt32(tableName, "github_run_number")
	_githubWorkflowRunDetails.GithubRunAttempt = field.NewInt32(tableName, "github_run_attempt")
	_githubWorkflowRunDetails.WorkflowID = field.NewInt64(tableName, "workflow_id")
	_githubWorkflowRunDetails.WorkflowName = field.NewString(tableName, "workflow_name")
	_githubWorkflowRunDetails.WorkflowPath = field.NewString(tableName, "workflow_path")
	_githubWorkflowRunDetails.Status = field.NewString(tableName, "status")
	_githubWorkflowRunDetails.Conclusion = field.NewString(tableName, "conclusion")
	_githubWorkflowRunDetails.HTMLURL = field.NewString(tableName, "html_url")
	_githubWorkflowRunDetails.JobsURL = field.NewString(tableName, "jobs_url")
	_githubWorkflowRunDetails.LogsURL = field.NewString(tableName, "logs_url")
	_githubWorkflowRunDetails.ArtifactsURL = field.NewString(tableName, "artifacts_url")
	_githubWorkflowRunDetails.CreatedAtGithub = field.NewTime(tableName, "created_at_github")
	_githubWorkflowRunDetails.UpdatedAtGithub = field.NewTime(tableName, "updated_at_github")
	_githubWorkflowRunDetails.RunStartedAt = field.NewTime(tableName, "run_started_at")
	_githubWorkflowRunDetails.RunCompletedAt = field.NewTime(tableName, "run_completed_at")
	_githubWorkflowRunDetails.DurationSeconds = field.NewInt32(tableName, "duration_seconds")
	_githubWorkflowRunDetails.Event = field.NewString(tableName, "event")
	_githubWorkflowRunDetails.TriggerActor = field.NewString(tableName, "trigger_actor")
	_githubWorkflowRunDetails.TriggerActorID = field.NewInt64(tableName, "trigger_actor_id")
	_githubWorkflowRunDetails.HeadSha = field.NewString(tableName, "head_sha")
	_githubWorkflowRunDetails.HeadBranch = field.NewString(tableName, "head_branch")
	_githubWorkflowRunDetails.HeadRepositoryFullName = field.NewString(tableName, "head_repository_full_name")
	_githubWorkflowRunDetails.BaseSha = field.NewString(tableName, "base_sha")
	_githubWorkflowRunDetails.BaseBranch = field.NewString(tableName, "base_branch")
	_githubWorkflowRunDetails.PullRequestNumber = field.NewInt32(tableName, "pull_request_number")
	_githubWorkflowRunDetails.PullRequestTitle = field.NewString(tableName, "pull_request_title")
	_githubWorkflowRunDetails.PullRequestURL = field.NewString(tableName, "pull_request_url")
	_githubWorkflowRunDetails.Jobs = field.NewField(tableName, "jobs")
	_githubWorkflowRunDetails.CreatedAt = field.NewTime(tableName, "created_at")

	_githubWorkflowRunDetails.fillFieldMap()

	return _githubWorkflowRunDetails
}

type githubWorkflowRunDetails struct {
	githubWorkflowRunDetailsDo githubWorkflowRunDetailsDo

	ALL                    field.Asterisk
	ID                     field.Int64
	RunID                  field.Int64
	GithubRunID            field.Int64
	GithubRunNumber        field.Int32
	GithubRunAttempt       field.Int32
	WorkflowID             field.Int64
	WorkflowName           field.String
	WorkflowPath           field.String
	Status                 field.String
	Conclusion             field.String
	HTMLURL                field.String
	JobsURL                field.String
	LogsURL                field.String
	ArtifactsURL           field.String
	CreatedAtGithub        field.Time
	UpdatedAtGithub        field.Time
	RunStartedAt           field.Time
	RunCompletedAt         field.Time
	DurationSeconds        field.Int32
	Event                  field.String
	TriggerActor           field.String
	TriggerActorID         field.Int64
	HeadSha                field.String
	HeadBranch             field.String
	HeadRepositoryFullName field.String
	BaseSha                field.String
	BaseBranch             field.String
	PullRequestNumber      field.Int32
	PullRequestTitle       field.String
	PullRequestURL         field.String
	Jobs                   field.Field
	CreatedAt              field.Time

	fieldMap map[string]field.Expr
}

func (g githubWorkflowRunDetails) Table(newTableName string) *githubWorkflowRunDetails {
	g.githubWorkflowRunDetailsDo.UseTable(newTableName)
	return g.updateTableName(newTableName)
}

func (g githubWorkflowRunDetails) As(alias string) *githubWorkflowRunDetails {
	g.githubWorkflowRunDetailsDo.DO = *(g.githubWorkflowRunDetailsDo.As(alias).(*gen.DO))
	return g.updateTableName(alias)
}

func (g *githubWorkflowRunDetails) updateTableName(table string) *githubWorkflowRunDetails {
	g.ALL = field.NewAsterisk(table)
	g.ID = field.NewInt64(table, "id")
	g.RunID = field.NewInt64(table, "run_id")
	g.GithubRunID = field.NewInt64(table, "github_run_id")
	g.GithubRunNumber = field.NewInt32(table, "github_run_number")
	g.GithubRunAttempt = field.NewInt32(table, "github_run_attempt")
	g.WorkflowID = field.NewInt64(table, "workflow_id")
	g.WorkflowName = field.NewString(table, "workflow_name")
	g.WorkflowPath = field.NewString(table, "workflow_path")
	g.Status = field.NewString(table, "status")
	g.Conclusion = field.NewString(table, "conclusion")
	g.HTMLURL = field.NewString(table, "html_url")
	g.JobsURL = field.NewString(table, "jobs_url")
	g.LogsURL = field.NewString(table, "logs_url")
	g.ArtifactsURL = field.NewString(table, "artifacts_url")
	g.CreatedAtGithub = field.NewTime(table, "created_at_github")
	g.UpdatedAtGithub = field.NewTime(table, "updated_at_github")
	g.RunStartedAt = field.NewTime(table, "run_started_at")
	g.RunCompletedAt = field.NewTime(table, "run_completed_at")
	g.DurationSeconds = field.NewInt32(table, "duration_seconds")
	g.Event = field.NewString(table, "event")
	g.TriggerActor = field.NewString(table, "trigger_actor")
	g.TriggerActorID = field.NewInt64(table, "trigger_actor_id")
	g.HeadSha = field.NewString(table, "head_sha")
	g.HeadBranch = field.NewString(table, "head_branch")
	g.HeadRepositoryFullName = field.NewString(table, "head_repository_full_name")
	g.BaseSha = field.NewString(table, "base_sha")
	g.BaseBranch = field.NewString(table, "base_branch")
	g.PullRequestNumber = field.NewInt32(table, "pull_request_number")
	g.PullRequestTitle = field.NewString(table, "pull_request_title")
	g.PullRequestURL = field.NewString(table, "pull_request_url")
	g.Jobs = field.NewField(table, "jobs")
	g.CreatedAt = field.NewTime(table, "created_at")

	g.fillFieldMap()

	return g
}

func (g *githubWorkflowRunDetails) WithContext(ctx context.Context) *githubWorkflowRunDetailsDo {
	return g.githubWorkflowRunDetailsDo.WithContext(ctx)
}

func (g githubWorkflowRunDetails) TableName() string { return g.githubWorkflowRunDetailsDo.TableName() }

func (g githubWorkflowRunDetails) Alias() string { return g.githubWorkflowRunDetailsDo.Alias() }

func (g githubWorkflowRunDetails) Columns(cols ...field.Expr) gen.Columns {
	return g.githubWorkflowRunDetailsDo.Columns(cols...)
}

func (g *githubWorkflowRunDetails) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := g.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (g *githubWorkflowRunDetails) fillFieldMap() {
	g.fieldMap = make(map[string]field.Expr, 32)
	g.fieldMap["id"] = g.ID
	g.fieldMap["run_id"] = g.RunID
	g.fieldMap["github_run_id"] = g.GithubRunID
	g.fieldMap["github_run_number"] = g.GithubRunNumber
	g.fieldMap["github_run_attempt"] = g.GithubRunAttempt
	g.fieldMap["workflow_id"] = g.WorkflowID
	g.fieldMap["workflow_name"] = g.WorkflowName
	g.fieldMap["workflow_path"] = g.WorkflowPath
	g.fieldMap["status"] = g.Status
	g.fieldMap["conclusion"] = g.Conclusion
	g.fieldMap["html_url"] = g.HTMLURL
	g.fieldMap["jobs_url"] = g.JobsURL
	g.fieldMap["logs_url"] = g.LogsURL
	g.fieldMap["artifacts_url"] = g.ArtifactsURL
	g.fieldMap["created_at_github"] = g.CreatedAtGithub
	g.fieldMap["updated_at_github"] = g.UpdatedAtGithub
	g.fieldMap["run_started_at"] = g.RunStartedAt
	g.fieldMap["run_completed_at"] = g.RunCompletedAt
	g.fieldMap["duration_seconds"] = g.DurationSeconds
	g.fieldMap["event"] = g.Event
	g.fieldMap["trigger_actor"] = g.TriggerActor
	g.fieldMap["trigger_actor_id"] = g.TriggerActorID
	g.fieldMap["head_sha"] = g.HeadSha
	g.fieldMap["head_branch"] = g.HeadBranch
	g.fieldMap["head_repository_full_name"] = g.HeadRepositoryFullName
	g.fieldMap["base_sha"] = g.BaseSha
	g.fieldMap["base_branch"] = g.BaseBranch
	g.fieldMap["pull_request_number"] = g.PullRequestNumber
	g.fieldMap["pull_request_title"] = g.PullRequestTitle
	g.fieldMap["pull_request_url"] = g.PullRequestURL
	g.fieldMap["jobs"] = g.Jobs
	g.fieldMap["created_at"] = g.CreatedAt
}

func (g githubWorkflowRunDetails) clone(db *gorm.DB) githubWorkflowRunDetails {
	g.githubWorkflowRunDetailsDo.ReplaceConnPool(db.Statement.ConnPool)
	return g
}

func (g githubWorkflowRunDetails) replaceDB(db *gorm.DB) githubWorkflowRunDetails {
	g.githubWorkflowRunDetailsDo.ReplaceDB(db)
	return g
}

type githubWorkflowRunDetailsDo struct{ gen.DO }

func (g githubWorkflowRunDetailsDo) Debug() *githubWorkflowRunDetailsDo {
	return g.withDO(g.DO.Debug())
}

func (g githubWorkflowRunDetailsDo) WithContext(ctx context.Context) *githubWorkflowRunDetailsDo {
	return g.withDO(g.DO.WithContext(ctx))
}

func (g githubWorkflowRunDetailsDo) ReadDB() *githubWorkflowRunDetailsDo {
	return g.Clauses(dbresolver.Read)
}

func (g githubWorkflowRunDetailsDo) WriteDB() *githubWorkflowRunDetailsDo {
	return g.Clauses(dbresolver.Write)
}

func (g githubWorkflowRunDetailsDo) Session(config *gorm.Session) *githubWorkflowRunDetailsDo {
	return g.withDO(g.DO.Session(config))
}

func (g githubWorkflowRunDetailsDo) Clauses(conds ...clause.Expression) *githubWorkflowRunDetailsDo {
	return g.withDO(g.DO.Clauses(conds...))
}

func (g githubWorkflowRunDetailsDo) Returning(value interface{}, columns ...string) *githubWorkflowRunDetailsDo {
	return g.withDO(g.DO.Returning(value, columns...))
}

func (g githubWorkflowRunDetailsDo) Not(conds ...gen.Condition) *githubWorkflowRunDetailsDo {
	return g.withDO(g.DO.Not(conds...))
}

func (g githubWorkflowRunDetailsDo) Or(conds ...gen.Condition) *githubWorkflowRunDetailsDo {
	return g.withDO(g.DO.Or(conds...))
}

func (g githubWorkflowRunDetailsDo) Select(conds ...field.Expr) *githubWorkflowRunDetailsDo {
	return g.withDO(g.DO.Select(conds...))
}

func (g githubWorkflowRunDetailsDo) Where(conds ...gen.Condition) *githubWorkflowRunDetailsDo {
	return g.withDO(g.DO.Where(conds...))
}

func (g githubWorkflowRunDetailsDo) Order(conds ...field.Expr) *githubWorkflowRunDetailsDo {
	return g.withDO(g.DO.Order(conds...))
}

func (g githubWorkflowRunDetailsDo) Distinct(cols ...field.Expr) *githubWorkflowRunDetailsDo {
	return g.withDO(g.DO.Distinct(cols...))
}

func (g githubWorkflowRunDetailsDo) Omit(cols ...field.Expr) *githubWorkflowRunDetailsDo {
	return g.withDO(g.DO.Omit(cols...))
}

func (g githubWorkflowRunDetailsDo) Join(table schema.Tabler, on ...field.Expr) *githubWorkflowRunDetailsDo {
	return g.withDO(g.DO.Join(table, on...))
}

func (g githubWorkflowRunDetailsDo) LeftJoin(table schema.Tabler, on ...field.Expr) *githubWorkflowRunDetailsDo {
	return g.withDO(g.DO.LeftJoin(table, on...))
}

func (g githubWorkflowRunDetailsDo) RightJoin(table schema.Tabler, on ...field.Expr) *githubWorkflowRunDetailsDo {
	return g.withDO(g.DO.RightJoin(table, on...))
}

func (g githubWorkflowRunDetailsDo) Group(cols ...field.Expr) *githubWorkflowRunDetailsDo {
	return g.withDO(g.DO.Group(cols...))
}

func (g githubWorkflowRunDetailsDo) Having(conds ...gen.Condition) *githubWorkflowRunDetailsDo {
	return g.withDO(g.DO.Having(conds...))
}

func (g githubWorkflowRunDetailsDo) Limit(limit int) *githubWorkflowRunDetailsDo {
	return g.withDO(g.DO.Limit(limit))
}

func (g githubWorkflowRunDetailsDo) Offset(offset int) *githubWorkflowRunDetailsDo {
	return g.withDO(g.DO.Offset(offset))
}

func (g githubWorkflowRunDetailsDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *githubWorkflowRunDetailsDo {
	return g.withDO(g.DO.Scopes(funcs...))
}

func (g githubWorkflowRunDetailsDo) Unscoped() *githubWorkflowRunDetailsDo {
	return g.withDO(g.DO.Unscoped())
}

func (g githubWorkflowRunDetailsDo) Create(values ...*model.GithubWorkflowRunDetails) error {
	if len(values) == 0 {
		return nil
	}
	return g.DO.Create(values)
}

func (g githubWorkflowRunDetailsDo) CreateInBatches(values []*model.GithubWorkflowRunDetails, batchSize int) error {
	return g.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (g githubWorkflowRunDetailsDo) Save(values ...*model.GithubWorkflowRunDetails) error {
	if len(values) == 0 {
		return nil
	}
	return g.DO.Save(values)
}

func (g githubWorkflowRunDetailsDo) First() (*model.GithubWorkflowRunDetails, error) {
	if result, err := g.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.GithubWorkflowRunDetails), nil
	}
}

func (g githubWorkflowRunDetailsDo) Take() (*model.GithubWorkflowRunDetails, error) {
	if result, err := g.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.GithubWorkflowRunDetails), nil
	}
}

func (g githubWorkflowRunDetailsDo) Last() (*model.GithubWorkflowRunDetails, error) {
	if result, err := g.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.GithubWorkflowRunDetails), nil
	}
}

func (g githubWorkflowRunDetailsDo) Find() ([]*model.GithubWorkflowRunDetails, error) {
	result, err := g.DO.Find()
	return result.([]*model.GithubWorkflowRunDetails), err
}

func (g githubWorkflowRunDetailsDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.GithubWorkflowRunDetails, err error) {
	buf := make([]*model.GithubWorkflowRunDetails, 0, batchSize)
	err = g.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (g githubWorkflowRunDetailsDo) FindInBatches(result *[]*model.GithubWorkflowRunDetails, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return g.DO.FindInBatches(result, batchSize, fc)
}

func (g githubWorkflowRunDetailsDo) Attrs(attrs ...field.AssignExpr) *githubWorkflowRunDetailsDo {
	return g.withDO(g.DO.Attrs(attrs...))
}

func (g githubWorkflowRunDetailsDo) Assign(attrs ...field.AssignExpr) *githubWorkflowRunDetailsDo {
	return g.withDO(g.DO.Assign(attrs...))
}

func (g githubWorkflowRunDetailsDo) Joins(fields ...field.RelationField) *githubWorkflowRunDetailsDo {
	for _, _f := range fields {
		g = *g.withDO(g.DO.Joins(_f))
	}
	return &g
}

func (g githubWorkflowRunDetailsDo) Preload(fields ...field.RelationField) *githubWorkflowRunDetailsDo {
	for _, _f := range fields {
		g = *g.withDO(g.DO.Preload(_f))
	}
	return &g
}

func (g githubWorkflowRunDetailsDo) FirstOrInit() (*model.GithubWorkflowRunDetails, error) {
	if result, err := g.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.GithubWorkflowRunDetails), nil
	}
}

func (g githubWorkflowRunDetailsDo) FirstOrCreate() (*model.GithubWorkflowRunDetails, error) {
	if result, err := g.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.GithubWorkflowRunDetails), nil
	}
}

func (g githubWorkflowRunDetailsDo) FindByPage(offset int, limit int) (result []*model.GithubWorkflowRunDetails, count int64, err error) {
	result, err = g.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = g.Offset(-1).Limit(-1).Count()
	return
}

func (g githubWorkflowRunDetailsDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = g.Count()
	if err != nil {
		return
	}

	err = g.Offset(offset).Limit(limit).Scan(result)
	return
}

func (g githubWorkflowRunDetailsDo) Scan(result interface{}) (err error) {
	return g.DO.Scan(result)
}

func (g githubWorkflowRunDetailsDo) Delete(models ...*model.GithubWorkflowRunDetails) (result gen.ResultInfo, err error) {
	return g.DO.Delete(models)
}

func (g *githubWorkflowRunDetailsDo) withDO(do gen.Dao) *githubWorkflowRunDetailsDo {
	g.DO = *do.(*gen.DO)
	return g
}
