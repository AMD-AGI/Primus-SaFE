// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dal

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/AMD-AGI/Primus-SaFE/Lens/core/pkg/database/model"
)

func newGithubWorkflowRuns(db *gorm.DB, opts ...gen.DOOption) githubWorkflowRuns {
	_githubWorkflowRuns := githubWorkflowRuns{}

	_githubWorkflowRuns.githubWorkflowRunsDo.UseDB(db, opts...)
	_githubWorkflowRuns.githubWorkflowRunsDo.UseModel(&model.GithubWorkflowRuns{})

	tableName := _githubWorkflowRuns.githubWorkflowRunsDo.TableName()
	_githubWorkflowRuns.ALL = field.NewAsterisk(tableName)
	_githubWorkflowRuns.ID = field.NewInt64(tableName, "id")
	_githubWorkflowRuns.ConfigID = field.NewInt64(tableName, "config_id")
	_githubWorkflowRuns.WorkloadUID = field.NewString(tableName, "workload_uid")
	_githubWorkflowRuns.WorkloadName = field.NewString(tableName, "workload_name")
	_githubWorkflowRuns.WorkloadNamespace = field.NewString(tableName, "workload_namespace")
	_githubWorkflowRuns.GithubRunID = field.NewInt64(tableName, "github_run_id")
	_githubWorkflowRuns.GithubRunNumber = field.NewInt32(tableName, "github_run_number")
	_githubWorkflowRuns.GithubJobID = field.NewInt64(tableName, "github_job_id")
	_githubWorkflowRuns.HeadSha = field.NewString(tableName, "head_sha")
	_githubWorkflowRuns.HeadBranch = field.NewString(tableName, "head_branch")
	_githubWorkflowRuns.WorkflowName = field.NewString(tableName, "workflow_name")
	_githubWorkflowRuns.Status = field.NewString(tableName, "status")
	_githubWorkflowRuns.TriggerSource = field.NewString(tableName, "trigger_source")
	_githubWorkflowRuns.FilesFound = field.NewInt32(tableName, "files_found")
	_githubWorkflowRuns.FilesProcessed = field.NewInt32(tableName, "files_processed")
	_githubWorkflowRuns.MetricsCount = field.NewInt32(tableName, "metrics_count")
	_githubWorkflowRuns.WorkloadStartedAt = field.NewTime(tableName, "workload_started_at")
	_githubWorkflowRuns.WorkloadCompletedAt = field.NewTime(tableName, "workload_completed_at")
	_githubWorkflowRuns.CollectionStartedAt = field.NewTime(tableName, "collection_started_at")
	_githubWorkflowRuns.CollectionCompletedAt = field.NewTime(tableName, "collection_completed_at")
	_githubWorkflowRuns.ErrorMessage = field.NewString(tableName, "error_message")
	_githubWorkflowRuns.RetryCount = field.NewInt32(tableName, "retry_count")
	_githubWorkflowRuns.CreatedAt = field.NewTime(tableName, "created_at")
	_githubWorkflowRuns.UpdatedAt = field.NewTime(tableName, "updated_at")
	_githubWorkflowRuns.RunnerSetID = field.NewInt64(tableName, "runner_set_id")
	_githubWorkflowRuns.RunnerSetName = field.NewString(tableName, "runner_set_name")
	_githubWorkflowRuns.RunnerSetNamespace = field.NewString(tableName, "runner_set_namespace")
	_githubWorkflowRuns.WorkflowStatus = field.NewString(tableName, "workflow_status")
	_githubWorkflowRuns.WorkflowConclusion = field.NewString(tableName, "workflow_conclusion")
	_githubWorkflowRuns.CollectionStatus = field.NewString(tableName, "collection_status")
	_githubWorkflowRuns.CurrentJobName = field.NewString(tableName, "current_job_name")
	_githubWorkflowRuns.CurrentStepName = field.NewString(tableName, "current_step_name")
	_githubWorkflowRuns.ProgressPercent = field.NewInt32(tableName, "progress_percent")
	_githubWorkflowRuns.LastSyncedAt = field.NewTime(tableName, "last_synced_at")

	_githubWorkflowRuns.fillFieldMap()

	return _githubWorkflowRuns
}

type githubWorkflowRuns struct {
	githubWorkflowRunsDo githubWorkflowRunsDo

	ALL                   field.Asterisk
	ID                    field.Int64
	ConfigID              field.Int64
	WorkloadUID           field.String
	WorkloadName          field.String
	WorkloadNamespace     field.String
	GithubRunID           field.Int64
	GithubRunNumber       field.Int32
	GithubJobID           field.Int64
	HeadSha               field.String
	HeadBranch            field.String
	WorkflowName          field.String
	Status                field.String
	TriggerSource         field.String
	FilesFound            field.Int32
	FilesProcessed        field.Int32
	MetricsCount          field.Int32
	WorkloadStartedAt     field.Time
	WorkloadCompletedAt   field.Time
	CollectionStartedAt   field.Time
	CollectionCompletedAt field.Time
	ErrorMessage          field.String
	RetryCount            field.Int32
	CreatedAt             field.Time
	UpdatedAt             field.Time
	RunnerSetID           field.Int64
	RunnerSetName         field.String
	RunnerSetNamespace    field.String
	WorkflowStatus        field.String // GitHub workflow execution status: queued, in_progress, completed, waiting, pending, requested
	WorkflowConclusion    field.String // GitHub workflow conclusion: success, failure, cancelled, skipped, neutral, timed_out, action_required
	CollectionStatus      field.String // Internal metrics collection status: pending, collecting, completed, failed, skipped
	CurrentJobName        field.String // Currently running job name from GitHub
	CurrentStepName       field.String // Currently running step name from GitHub
	ProgressPercent       field.Int32  // Overall workflow progress percentage (0-100)
	LastSyncedAt          field.Time   // Last time state was synced from GitHub API

	fieldMap map[string]field.Expr
}

func (g githubWorkflowRuns) Table(newTableName string) *githubWorkflowRuns {
	g.githubWorkflowRunsDo.UseTable(newTableName)
	return g.updateTableName(newTableName)
}

func (g githubWorkflowRuns) As(alias string) *githubWorkflowRuns {
	g.githubWorkflowRunsDo.DO = *(g.githubWorkflowRunsDo.As(alias).(*gen.DO))
	return g.updateTableName(alias)
}

func (g *githubWorkflowRuns) updateTableName(table string) *githubWorkflowRuns {
	g.ALL = field.NewAsterisk(table)
	g.ID = field.NewInt64(table, "id")
	g.ConfigID = field.NewInt64(table, "config_id")
	g.WorkloadUID = field.NewString(table, "workload_uid")
	g.WorkloadName = field.NewString(table, "workload_name")
	g.WorkloadNamespace = field.NewString(table, "workload_namespace")
	g.GithubRunID = field.NewInt64(table, "github_run_id")
	g.GithubRunNumber = field.NewInt32(table, "github_run_number")
	g.GithubJobID = field.NewInt64(table, "github_job_id")
	g.HeadSha = field.NewString(table, "head_sha")
	g.HeadBranch = field.NewString(table, "head_branch")
	g.WorkflowName = field.NewString(table, "workflow_name")
	g.Status = field.NewString(table, "status")
	g.TriggerSource = field.NewString(table, "trigger_source")
	g.FilesFound = field.NewInt32(table, "files_found")
	g.FilesProcessed = field.NewInt32(table, "files_processed")
	g.MetricsCount = field.NewInt32(table, "metrics_count")
	g.WorkloadStartedAt = field.NewTime(table, "workload_started_at")
	g.WorkloadCompletedAt = field.NewTime(table, "workload_completed_at")
	g.CollectionStartedAt = field.NewTime(table, "collection_started_at")
	g.CollectionCompletedAt = field.NewTime(table, "collection_completed_at")
	g.ErrorMessage = field.NewString(table, "error_message")
	g.RetryCount = field.NewInt32(table, "retry_count")
	g.CreatedAt = field.NewTime(table, "created_at")
	g.UpdatedAt = field.NewTime(table, "updated_at")
	g.RunnerSetID = field.NewInt64(table, "runner_set_id")
	g.RunnerSetName = field.NewString(table, "runner_set_name")
	g.RunnerSetNamespace = field.NewString(table, "runner_set_namespace")
	g.WorkflowStatus = field.NewString(table, "workflow_status")
	g.WorkflowConclusion = field.NewString(table, "workflow_conclusion")
	g.CollectionStatus = field.NewString(table, "collection_status")
	g.CurrentJobName = field.NewString(table, "current_job_name")
	g.CurrentStepName = field.NewString(table, "current_step_name")
	g.ProgressPercent = field.NewInt32(table, "progress_percent")
	g.LastSyncedAt = field.NewTime(table, "last_synced_at")

	g.fillFieldMap()

	return g
}

func (g *githubWorkflowRuns) WithContext(ctx context.Context) *githubWorkflowRunsDo {
	return g.githubWorkflowRunsDo.WithContext(ctx)
}

func (g githubWorkflowRuns) TableName() string { return g.githubWorkflowRunsDo.TableName() }

func (g githubWorkflowRuns) Alias() string { return g.githubWorkflowRunsDo.Alias() }

func (g githubWorkflowRuns) Columns(cols ...field.Expr) gen.Columns {
	return g.githubWorkflowRunsDo.Columns(cols...)
}

func (g *githubWorkflowRuns) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := g.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (g *githubWorkflowRuns) fillFieldMap() {
	g.fieldMap = make(map[string]field.Expr, 34)
	g.fieldMap["id"] = g.ID
	g.fieldMap["config_id"] = g.ConfigID
	g.fieldMap["workload_uid"] = g.WorkloadUID
	g.fieldMap["workload_name"] = g.WorkloadName
	g.fieldMap["workload_namespace"] = g.WorkloadNamespace
	g.fieldMap["github_run_id"] = g.GithubRunID
	g.fieldMap["github_run_number"] = g.GithubRunNumber
	g.fieldMap["github_job_id"] = g.GithubJobID
	g.fieldMap["head_sha"] = g.HeadSha
	g.fieldMap["head_branch"] = g.HeadBranch
	g.fieldMap["workflow_name"] = g.WorkflowName
	g.fieldMap["status"] = g.Status
	g.fieldMap["trigger_source"] = g.TriggerSource
	g.fieldMap["files_found"] = g.FilesFound
	g.fieldMap["files_processed"] = g.FilesProcessed
	g.fieldMap["metrics_count"] = g.MetricsCount
	g.fieldMap["workload_started_at"] = g.WorkloadStartedAt
	g.fieldMap["workload_completed_at"] = g.WorkloadCompletedAt
	g.fieldMap["collection_started_at"] = g.CollectionStartedAt
	g.fieldMap["collection_completed_at"] = g.CollectionCompletedAt
	g.fieldMap["error_message"] = g.ErrorMessage
	g.fieldMap["retry_count"] = g.RetryCount
	g.fieldMap["created_at"] = g.CreatedAt
	g.fieldMap["updated_at"] = g.UpdatedAt
	g.fieldMap["runner_set_id"] = g.RunnerSetID
	g.fieldMap["runner_set_name"] = g.RunnerSetName
	g.fieldMap["runner_set_namespace"] = g.RunnerSetNamespace
	g.fieldMap["workflow_status"] = g.WorkflowStatus
	g.fieldMap["workflow_conclusion"] = g.WorkflowConclusion
	g.fieldMap["collection_status"] = g.CollectionStatus
	g.fieldMap["current_job_name"] = g.CurrentJobName
	g.fieldMap["current_step_name"] = g.CurrentStepName
	g.fieldMap["progress_percent"] = g.ProgressPercent
	g.fieldMap["last_synced_at"] = g.LastSyncedAt
}

func (g githubWorkflowRuns) clone(db *gorm.DB) githubWorkflowRuns {
	g.githubWorkflowRunsDo.ReplaceConnPool(db.Statement.ConnPool)
	return g
}

func (g githubWorkflowRuns) replaceDB(db *gorm.DB) githubWorkflowRuns {
	g.githubWorkflowRunsDo.ReplaceDB(db)
	return g
}

type githubWorkflowRunsDo struct{ gen.DO }

func (g githubWorkflowRunsDo) Debug() *githubWorkflowRunsDo {
	return g.withDO(g.DO.Debug())
}

func (g githubWorkflowRunsDo) WithContext(ctx context.Context) *githubWorkflowRunsDo {
	return g.withDO(g.DO.WithContext(ctx))
}

func (g githubWorkflowRunsDo) ReadDB() *githubWorkflowRunsDo {
	return g.Clauses(dbresolver.Read)
}

func (g githubWorkflowRunsDo) WriteDB() *githubWorkflowRunsDo {
	return g.Clauses(dbresolver.Write)
}

func (g githubWorkflowRunsDo) Session(config *gorm.Session) *githubWorkflowRunsDo {
	return g.withDO(g.DO.Session(config))
}

func (g githubWorkflowRunsDo) Clauses(conds ...clause.Expression) *githubWorkflowRunsDo {
	return g.withDO(g.DO.Clauses(conds...))
}

func (g githubWorkflowRunsDo) Returning(value interface{}, columns ...string) *githubWorkflowRunsDo {
	return g.withDO(g.DO.Returning(value, columns...))
}

func (g githubWorkflowRunsDo) Not(conds ...gen.Condition) *githubWorkflowRunsDo {
	return g.withDO(g.DO.Not(conds...))
}

func (g githubWorkflowRunsDo) Or(conds ...gen.Condition) *githubWorkflowRunsDo {
	return g.withDO(g.DO.Or(conds...))
}

func (g githubWorkflowRunsDo) Select(conds ...field.Expr) *githubWorkflowRunsDo {
	return g.withDO(g.DO.Select(conds...))
}

func (g githubWorkflowRunsDo) Where(conds ...gen.Condition) *githubWorkflowRunsDo {
	return g.withDO(g.DO.Where(conds...))
}

func (g githubWorkflowRunsDo) Order(conds ...field.Expr) *githubWorkflowRunsDo {
	return g.withDO(g.DO.Order(conds...))
}

func (g githubWorkflowRunsDo) Distinct(cols ...field.Expr) *githubWorkflowRunsDo {
	return g.withDO(g.DO.Distinct(cols...))
}

func (g githubWorkflowRunsDo) Omit(cols ...field.Expr) *githubWorkflowRunsDo {
	return g.withDO(g.DO.Omit(cols...))
}

func (g githubWorkflowRunsDo) Join(table schema.Tabler, on ...field.Expr) *githubWorkflowRunsDo {
	return g.withDO(g.DO.Join(table, on...))
}

func (g githubWorkflowRunsDo) LeftJoin(table schema.Tabler, on ...field.Expr) *githubWorkflowRunsDo {
	return g.withDO(g.DO.LeftJoin(table, on...))
}

func (g githubWorkflowRunsDo) RightJoin(table schema.Tabler, on ...field.Expr) *githubWorkflowRunsDo {
	return g.withDO(g.DO.RightJoin(table, on...))
}

func (g githubWorkflowRunsDo) Group(cols ...field.Expr) *githubWorkflowRunsDo {
	return g.withDO(g.DO.Group(cols...))
}

func (g githubWorkflowRunsDo) Having(conds ...gen.Condition) *githubWorkflowRunsDo {
	return g.withDO(g.DO.Having(conds...))
}

func (g githubWorkflowRunsDo) Limit(limit int) *githubWorkflowRunsDo {
	return g.withDO(g.DO.Limit(limit))
}

func (g githubWorkflowRunsDo) Offset(offset int) *githubWorkflowRunsDo {
	return g.withDO(g.DO.Offset(offset))
}

func (g githubWorkflowRunsDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *githubWorkflowRunsDo {
	return g.withDO(g.DO.Scopes(funcs...))
}

func (g githubWorkflowRunsDo) Unscoped() *githubWorkflowRunsDo {
	return g.withDO(g.DO.Unscoped())
}

func (g githubWorkflowRunsDo) Create(values ...*model.GithubWorkflowRuns) error {
	if len(values) == 0 {
		return nil
	}
	return g.DO.Create(values)
}

func (g githubWorkflowRunsDo) CreateInBatches(values []*model.GithubWorkflowRuns, batchSize int) error {
	return g.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (g githubWorkflowRunsDo) Save(values ...*model.GithubWorkflowRuns) error {
	if len(values) == 0 {
		return nil
	}
	return g.DO.Save(values)
}

func (g githubWorkflowRunsDo) First() (*model.GithubWorkflowRuns, error) {
	if result, err := g.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.GithubWorkflowRuns), nil
	}
}

func (g githubWorkflowRunsDo) Take() (*model.GithubWorkflowRuns, error) {
	if result, err := g.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.GithubWorkflowRuns), nil
	}
}

func (g githubWorkflowRunsDo) Last() (*model.GithubWorkflowRuns, error) {
	if result, err := g.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.GithubWorkflowRuns), nil
	}
}

func (g githubWorkflowRunsDo) Find() ([]*model.GithubWorkflowRuns, error) {
	result, err := g.DO.Find()
	return result.([]*model.GithubWorkflowRuns), err
}

func (g githubWorkflowRunsDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.GithubWorkflowRuns, err error) {
	buf := make([]*model.GithubWorkflowRuns, 0, batchSize)
	err = g.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (g githubWorkflowRunsDo) FindInBatches(result *[]*model.GithubWorkflowRuns, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return g.DO.FindInBatches(result, batchSize, fc)
}

func (g githubWorkflowRunsDo) Attrs(attrs ...field.AssignExpr) *githubWorkflowRunsDo {
	return g.withDO(g.DO.Attrs(attrs...))
}

func (g githubWorkflowRunsDo) Assign(attrs ...field.AssignExpr) *githubWorkflowRunsDo {
	return g.withDO(g.DO.Assign(attrs...))
}

func (g githubWorkflowRunsDo) Joins(fields ...field.RelationField) *githubWorkflowRunsDo {
	for _, _f := range fields {
		g = *g.withDO(g.DO.Joins(_f))
	}
	return &g
}

func (g githubWorkflowRunsDo) Preload(fields ...field.RelationField) *githubWorkflowRunsDo {
	for _, _f := range fields {
		g = *g.withDO(g.DO.Preload(_f))
	}
	return &g
}

func (g githubWorkflowRunsDo) FirstOrInit() (*model.GithubWorkflowRuns, error) {
	if result, err := g.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.GithubWorkflowRuns), nil
	}
}

func (g githubWorkflowRunsDo) FirstOrCreate() (*model.GithubWorkflowRuns, error) {
	if result, err := g.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.GithubWorkflowRuns), nil
	}
}

func (g githubWorkflowRunsDo) FindByPage(offset int, limit int) (result []*model.GithubWorkflowRuns, count int64, err error) {
	result, err = g.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = g.Offset(-1).Limit(-1).Count()
	return
}

func (g githubWorkflowRunsDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = g.Count()
	if err != nil {
		return
	}

	err = g.Offset(offset).Limit(limit).Scan(result)
	return
}

func (g githubWorkflowRunsDo) Scan(result interface{}) (err error) {
	return g.DO.Scan(result)
}

func (g githubWorkflowRunsDo) Delete(models ...*model.GithubWorkflowRuns) (result gen.ResultInfo, err error) {
	return g.DO.Delete(models)
}

func (g *githubWorkflowRunsDo) withDO(do gen.Dao) *githubWorkflowRunsDo {
	g.DO = *do.(*gen.DO)
	return g
}
