// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dal

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/AMD-AGI/Primus-SaFE/Lens/core/pkg/database/model"
)

func newJobExecutionHistory(db *gorm.DB, opts ...gen.DOOption) jobExecutionHistory {
	_jobExecutionHistory := jobExecutionHistory{}

	_jobExecutionHistory.jobExecutionHistoryDo.UseDB(db, opts...)
	_jobExecutionHistory.jobExecutionHistoryDo.UseModel(&model.JobExecutionHistory{})

	tableName := _jobExecutionHistory.jobExecutionHistoryDo.TableName()
	_jobExecutionHistory.ALL = field.NewAsterisk(tableName)
	_jobExecutionHistory.ID = field.NewInt64(tableName, "id")
	_jobExecutionHistory.JobName = field.NewString(tableName, "job_name")
	_jobExecutionHistory.JobType = field.NewString(tableName, "job_type")
	_jobExecutionHistory.Schedule = field.NewString(tableName, "schedule")
	_jobExecutionHistory.Status = field.NewString(tableName, "status")
	_jobExecutionHistory.StartedAt = field.NewTime(tableName, "started_at")
	_jobExecutionHistory.EndedAt = field.NewTime(tableName, "ended_at")
	_jobExecutionHistory.DurationSeconds = field.NewFloat64(tableName, "duration_seconds")
	_jobExecutionHistory.ErrorMessage = field.NewString(tableName, "error_message")
	_jobExecutionHistory.ErrorStack = field.NewString(tableName, "error_stack")
	_jobExecutionHistory.ClusterName = field.NewString(tableName, "cluster_name")
	_jobExecutionHistory.Hostname = field.NewString(tableName, "hostname")
	_jobExecutionHistory.Metadata = field.NewField(tableName, "metadata")
	_jobExecutionHistory.ExecutionStats = field.NewField(tableName, "execution_stats")
	_jobExecutionHistory.CreatedAt = field.NewTime(tableName, "created_at")

	_jobExecutionHistory.fillFieldMap()

	return _jobExecutionHistory
}

type jobExecutionHistory struct {
	jobExecutionHistoryDo

	ALL             field.Asterisk
	ID              field.Int64
	JobName         field.String // Name of the job (extracted from job type)
	JobType         field.String // Full type name of the job
	Schedule        field.String
	Status          field.String  // Execution status: running, success, failed, cancelled, timeout
	StartedAt       field.Time    // Timestamp when the job execution started
	EndedAt         field.Time    // Timestamp when the job execution ended (NULL if still running)
	DurationSeconds field.Float64 // Total execution duration in seconds
	ErrorMessage    field.String  // Error message if execution failed
	ErrorStack      field.String  // Full error stack trace for debugging
	ClusterName     field.String
	Hostname        field.String
	Metadata        field.Field // Additional metadata about the execution context
	ExecutionStats  field.Field // Metrics collected during job execution (e.g., records processed, bytes transferred)
	CreatedAt       field.Time

	fieldMap map[string]field.Expr
}

func (j jobExecutionHistory) Table(newTableName string) *jobExecutionHistory {
	j.jobExecutionHistoryDo.UseTable(newTableName)
	return j.updateTableName(newTableName)
}

func (j jobExecutionHistory) As(alias string) *jobExecutionHistory {
	j.jobExecutionHistoryDo.DO = *(j.jobExecutionHistoryDo.As(alias).(*gen.DO))
	return j.updateTableName(alias)
}

func (j *jobExecutionHistory) updateTableName(table string) *jobExecutionHistory {
	j.ALL = field.NewAsterisk(table)
	j.ID = field.NewInt64(table, "id")
	j.JobName = field.NewString(table, "job_name")
	j.JobType = field.NewString(table, "job_type")
	j.Schedule = field.NewString(table, "schedule")
	j.Status = field.NewString(table, "status")
	j.StartedAt = field.NewTime(table, "started_at")
	j.EndedAt = field.NewTime(table, "ended_at")
	j.DurationSeconds = field.NewFloat64(table, "duration_seconds")
	j.ErrorMessage = field.NewString(table, "error_message")
	j.ErrorStack = field.NewString(table, "error_stack")
	j.ClusterName = field.NewString(table, "cluster_name")
	j.Hostname = field.NewString(table, "hostname")
	j.Metadata = field.NewField(table, "metadata")
	j.ExecutionStats = field.NewField(table, "execution_stats")
	j.CreatedAt = field.NewTime(table, "created_at")

	j.fillFieldMap()

	return j
}

func (j *jobExecutionHistory) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := j.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (j *jobExecutionHistory) fillFieldMap() {
	j.fieldMap = make(map[string]field.Expr, 15)
	j.fieldMap["id"] = j.ID
	j.fieldMap["job_name"] = j.JobName
	j.fieldMap["job_type"] = j.JobType
	j.fieldMap["schedule"] = j.Schedule
	j.fieldMap["status"] = j.Status
	j.fieldMap["started_at"] = j.StartedAt
	j.fieldMap["ended_at"] = j.EndedAt
	j.fieldMap["duration_seconds"] = j.DurationSeconds
	j.fieldMap["error_message"] = j.ErrorMessage
	j.fieldMap["error_stack"] = j.ErrorStack
	j.fieldMap["cluster_name"] = j.ClusterName
	j.fieldMap["hostname"] = j.Hostname
	j.fieldMap["metadata"] = j.Metadata
	j.fieldMap["execution_stats"] = j.ExecutionStats
	j.fieldMap["created_at"] = j.CreatedAt
}

func (j jobExecutionHistory) clone(db *gorm.DB) jobExecutionHistory {
	j.jobExecutionHistoryDo.ReplaceConnPool(db.Statement.ConnPool)
	return j
}

func (j jobExecutionHistory) replaceDB(db *gorm.DB) jobExecutionHistory {
	j.jobExecutionHistoryDo.ReplaceDB(db)
	return j
}

type jobExecutionHistoryDo struct{ gen.DO }

type IJobExecutionHistoryDo interface {
	gen.SubQuery
	Debug() IJobExecutionHistoryDo
	WithContext(ctx context.Context) IJobExecutionHistoryDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IJobExecutionHistoryDo
	WriteDB() IJobExecutionHistoryDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IJobExecutionHistoryDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IJobExecutionHistoryDo
	Not(conds ...gen.Condition) IJobExecutionHistoryDo
	Or(conds ...gen.Condition) IJobExecutionHistoryDo
	Select(conds ...field.Expr) IJobExecutionHistoryDo
	Where(conds ...gen.Condition) IJobExecutionHistoryDo
	Order(conds ...field.Expr) IJobExecutionHistoryDo
	Distinct(cols ...field.Expr) IJobExecutionHistoryDo
	Omit(cols ...field.Expr) IJobExecutionHistoryDo
	Join(table schema.Tabler, on ...field.Expr) IJobExecutionHistoryDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IJobExecutionHistoryDo
	RightJoin(table schema.Tabler, on ...field.Expr) IJobExecutionHistoryDo
	Group(cols ...field.Expr) IJobExecutionHistoryDo
	Having(conds ...gen.Condition) IJobExecutionHistoryDo
	Limit(limit int) IJobExecutionHistoryDo
	Offset(offset int) IJobExecutionHistoryDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IJobExecutionHistoryDo
	Unscoped() IJobExecutionHistoryDo
	Create(values ...*model.JobExecutionHistory) error
	CreateInBatches(values []*model.JobExecutionHistory, batchSize int) error
	Save(values ...*model.JobExecutionHistory) error
	First() (*model.JobExecutionHistory, error)
	Take() (*model.JobExecutionHistory, error)
	Last() (*model.JobExecutionHistory, error)
	Find() ([]*model.JobExecutionHistory, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.JobExecutionHistory, err error)
	FindInBatches(result *[]*model.JobExecutionHistory, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.JobExecutionHistory) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IJobExecutionHistoryDo
	Assign(attrs ...field.AssignExpr) IJobExecutionHistoryDo
	Joins(fields ...field.RelationField) IJobExecutionHistoryDo
	Preload(fields ...field.RelationField) IJobExecutionHistoryDo
	FirstOrInit() (*model.JobExecutionHistory, error)
	FirstOrCreate() (*model.JobExecutionHistory, error)
	FindByPage(offset int, limit int) (result []*model.JobExecutionHistory, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IJobExecutionHistoryDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (j jobExecutionHistoryDo) Debug() IJobExecutionHistoryDo {
	return j.withDO(j.DO.Debug())
}

func (j jobExecutionHistoryDo) WithContext(ctx context.Context) IJobExecutionHistoryDo {
	return j.withDO(j.DO.WithContext(ctx))
}

func (j jobExecutionHistoryDo) ReadDB() IJobExecutionHistoryDo {
	return j.Clauses(dbresolver.Read)
}

func (j jobExecutionHistoryDo) WriteDB() IJobExecutionHistoryDo {
	return j.Clauses(dbresolver.Write)
}

func (j jobExecutionHistoryDo) Session(config *gorm.Session) IJobExecutionHistoryDo {
	return j.withDO(j.DO.Session(config))
}

func (j jobExecutionHistoryDo) Clauses(conds ...clause.Expression) IJobExecutionHistoryDo {
	return j.withDO(j.DO.Clauses(conds...))
}

func (j jobExecutionHistoryDo) Returning(value interface{}, columns ...string) IJobExecutionHistoryDo {
	return j.withDO(j.DO.Returning(value, columns...))
}

func (j jobExecutionHistoryDo) Not(conds ...gen.Condition) IJobExecutionHistoryDo {
	return j.withDO(j.DO.Not(conds...))
}

func (j jobExecutionHistoryDo) Or(conds ...gen.Condition) IJobExecutionHistoryDo {
	return j.withDO(j.DO.Or(conds...))
}

func (j jobExecutionHistoryDo) Select(conds ...field.Expr) IJobExecutionHistoryDo {
	return j.withDO(j.DO.Select(conds...))
}

func (j jobExecutionHistoryDo) Where(conds ...gen.Condition) IJobExecutionHistoryDo {
	return j.withDO(j.DO.Where(conds...))
}

func (j jobExecutionHistoryDo) Order(conds ...field.Expr) IJobExecutionHistoryDo {
	return j.withDO(j.DO.Order(conds...))
}

func (j jobExecutionHistoryDo) Distinct(cols ...field.Expr) IJobExecutionHistoryDo {
	return j.withDO(j.DO.Distinct(cols...))
}

func (j jobExecutionHistoryDo) Omit(cols ...field.Expr) IJobExecutionHistoryDo {
	return j.withDO(j.DO.Omit(cols...))
}

func (j jobExecutionHistoryDo) Join(table schema.Tabler, on ...field.Expr) IJobExecutionHistoryDo {
	return j.withDO(j.DO.Join(table, on...))
}

func (j jobExecutionHistoryDo) LeftJoin(table schema.Tabler, on ...field.Expr) IJobExecutionHistoryDo {
	return j.withDO(j.DO.LeftJoin(table, on...))
}

func (j jobExecutionHistoryDo) RightJoin(table schema.Tabler, on ...field.Expr) IJobExecutionHistoryDo {
	return j.withDO(j.DO.RightJoin(table, on...))
}

func (j jobExecutionHistoryDo) Group(cols ...field.Expr) IJobExecutionHistoryDo {
	return j.withDO(j.DO.Group(cols...))
}

func (j jobExecutionHistoryDo) Having(conds ...gen.Condition) IJobExecutionHistoryDo {
	return j.withDO(j.DO.Having(conds...))
}

func (j jobExecutionHistoryDo) Limit(limit int) IJobExecutionHistoryDo {
	return j.withDO(j.DO.Limit(limit))
}

func (j jobExecutionHistoryDo) Offset(offset int) IJobExecutionHistoryDo {
	return j.withDO(j.DO.Offset(offset))
}

func (j jobExecutionHistoryDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IJobExecutionHistoryDo {
	return j.withDO(j.DO.Scopes(funcs...))
}

func (j jobExecutionHistoryDo) Unscoped() IJobExecutionHistoryDo {
	return j.withDO(j.DO.Unscoped())
}

func (j jobExecutionHistoryDo) Create(values ...*model.JobExecutionHistory) error {
	if len(values) == 0 {
		return nil
	}
	return j.DO.Create(values)
}

func (j jobExecutionHistoryDo) CreateInBatches(values []*model.JobExecutionHistory, batchSize int) error {
	return j.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (j jobExecutionHistoryDo) Save(values ...*model.JobExecutionHistory) error {
	if len(values) == 0 {
		return nil
	}
	return j.DO.Save(values)
}

func (j jobExecutionHistoryDo) First() (*model.JobExecutionHistory, error) {
	if result, err := j.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.JobExecutionHistory), nil
	}
}

func (j jobExecutionHistoryDo) Take() (*model.JobExecutionHistory, error) {
	if result, err := j.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.JobExecutionHistory), nil
	}
}

func (j jobExecutionHistoryDo) Last() (*model.JobExecutionHistory, error) {
	if result, err := j.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.JobExecutionHistory), nil
	}
}

func (j jobExecutionHistoryDo) Find() ([]*model.JobExecutionHistory, error) {
	result, err := j.DO.Find()
	return result.([]*model.JobExecutionHistory), err
}

func (j jobExecutionHistoryDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.JobExecutionHistory, err error) {
	buf := make([]*model.JobExecutionHistory, 0, batchSize)
	err = j.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (j jobExecutionHistoryDo) FindInBatches(result *[]*model.JobExecutionHistory, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return j.DO.FindInBatches(result, batchSize, fc)
}

func (j jobExecutionHistoryDo) Attrs(attrs ...field.AssignExpr) IJobExecutionHistoryDo {
	return j.withDO(j.DO.Attrs(attrs...))
}

func (j jobExecutionHistoryDo) Assign(attrs ...field.AssignExpr) IJobExecutionHistoryDo {
	return j.withDO(j.DO.Assign(attrs...))
}

func (j jobExecutionHistoryDo) Joins(fields ...field.RelationField) IJobExecutionHistoryDo {
	for _, _f := range fields {
		j = *j.withDO(j.DO.Joins(_f))
	}
	return &j
}

func (j jobExecutionHistoryDo) Preload(fields ...field.RelationField) IJobExecutionHistoryDo {
	for _, _f := range fields {
		j = *j.withDO(j.DO.Preload(_f))
	}
	return &j
}

func (j jobExecutionHistoryDo) FirstOrInit() (*model.JobExecutionHistory, error) {
	if result, err := j.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.JobExecutionHistory), nil
	}
}

func (j jobExecutionHistoryDo) FirstOrCreate() (*model.JobExecutionHistory, error) {
	if result, err := j.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.JobExecutionHistory), nil
	}
}

func (j jobExecutionHistoryDo) FindByPage(offset int, limit int) (result []*model.JobExecutionHistory, count int64, err error) {
	result, err = j.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = j.Offset(-1).Limit(-1).Count()
	return
}

func (j jobExecutionHistoryDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = j.Count()
	if err != nil {
		return
	}

	err = j.Offset(offset).Limit(limit).Scan(result)
	return
}

func (j jobExecutionHistoryDo) Scan(result interface{}) (err error) {
	return j.DO.Scan(result)
}

func (j jobExecutionHistoryDo) Delete(models ...*model.JobExecutionHistory) (result gen.ResultInfo, err error) {
	return j.DO.Delete(models)
}

func (j *jobExecutionHistoryDo) withDO(do gen.Dao) *jobExecutionHistoryDo {
	j.DO = *do.(*gen.DO)
	return j
}
