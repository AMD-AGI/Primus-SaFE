// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dal

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/AMD-AGI/Primus-SaFE/Lens/core/pkg/database/model"
)

func newProfilerFiles(db *gorm.DB, opts ...gen.DOOption) profilerFiles {
	_profilerFiles := profilerFiles{}

	_profilerFiles.profilerFilesDo.UseDB(db, opts...)
	_profilerFiles.profilerFilesDo.UseModel(&model.ProfilerFiles{})

	tableName := _profilerFiles.profilerFilesDo.TableName()
	_profilerFiles.ALL = field.NewAsterisk(tableName)
	_profilerFiles.ID = field.NewInt32(tableName, "id")
	_profilerFiles.WorkloadUID = field.NewString(tableName, "workload_uid")
	_profilerFiles.PodUID = field.NewString(tableName, "pod_uid")
	_profilerFiles.PodName = field.NewString(tableName, "pod_name")
	_profilerFiles.PodNamespace = field.NewString(tableName, "pod_namespace")
	_profilerFiles.FileName = field.NewString(tableName, "file_name")
	_profilerFiles.FilePath = field.NewString(tableName, "file_path")
	_profilerFiles.FileType = field.NewString(tableName, "file_type")
	_profilerFiles.FileSize = field.NewInt64(tableName, "file_size")
	_profilerFiles.StorageType = field.NewString(tableName, "storage_type")
	_profilerFiles.StoragePath = field.NewString(tableName, "storage_path")
	_profilerFiles.StorageBucket = field.NewString(tableName, "storage_bucket")
	_profilerFiles.DownloadURL = field.NewString(tableName, "download_url")
	_profilerFiles.Confidence = field.NewString(tableName, "confidence")
	_profilerFiles.SourcePid = field.NewInt32(tableName, "source_pid")
	_profilerFiles.DetectedAt = field.NewTime(tableName, "detected_at")
	_profilerFiles.CollectedAt = field.NewTime(tableName, "collected_at")
	_profilerFiles.ExpiresAt = field.NewTime(tableName, "expires_at")
	_profilerFiles.CreatedAt = field.NewTime(tableName, "created_at")
	_profilerFiles.UpdatedAt = field.NewTime(tableName, "updated_at")
	_profilerFiles.Metadata = field.NewField(tableName, "metadata")

	_profilerFiles.fillFieldMap()

	return _profilerFiles
}

type profilerFiles struct {
	profilerFilesDo profilerFilesDo

	ALL           field.Asterisk
	ID            field.Int32
	WorkloadUID   field.String
	PodUID        field.String
	PodName       field.String
	PodNamespace  field.String
	FileName      field.String
	FilePath      field.String
	FileType      field.String
	FileSize      field.Int64
	StorageType   field.String
	StoragePath   field.String
	StorageBucket field.String
	DownloadURL   field.String
	Confidence    field.String
	SourcePid     field.Int32
	DetectedAt    field.Time
	CollectedAt   field.Time
	ExpiresAt     field.Time
	CreatedAt     field.Time
	UpdatedAt     field.Time
	Metadata      field.Field

	fieldMap map[string]field.Expr
}

func (p profilerFiles) Table(newTableName string) *profilerFiles {
	p.profilerFilesDo.UseTable(newTableName)
	return p.updateTableName(newTableName)
}

func (p profilerFiles) As(alias string) *profilerFiles {
	p.profilerFilesDo.DO = *(p.profilerFilesDo.As(alias).(*gen.DO))
	return p.updateTableName(alias)
}

func (p *profilerFiles) updateTableName(table string) *profilerFiles {
	p.ALL = field.NewAsterisk(table)
	p.ID = field.NewInt32(table, "id")
	p.WorkloadUID = field.NewString(table, "workload_uid")
	p.PodUID = field.NewString(table, "pod_uid")
	p.PodName = field.NewString(table, "pod_name")
	p.PodNamespace = field.NewString(table, "pod_namespace")
	p.FileName = field.NewString(table, "file_name")
	p.FilePath = field.NewString(table, "file_path")
	p.FileType = field.NewString(table, "file_type")
	p.FileSize = field.NewInt64(table, "file_size")
	p.StorageType = field.NewString(table, "storage_type")
	p.StoragePath = field.NewString(table, "storage_path")
	p.StorageBucket = field.NewString(table, "storage_bucket")
	p.DownloadURL = field.NewString(table, "download_url")
	p.Confidence = field.NewString(table, "confidence")
	p.SourcePid = field.NewInt32(table, "source_pid")
	p.DetectedAt = field.NewTime(table, "detected_at")
	p.CollectedAt = field.NewTime(table, "collected_at")
	p.ExpiresAt = field.NewTime(table, "expires_at")
	p.CreatedAt = field.NewTime(table, "created_at")
	p.UpdatedAt = field.NewTime(table, "updated_at")
	p.Metadata = field.NewField(table, "metadata")

	p.fillFieldMap()

	return p
}

func (p *profilerFiles) WithContext(ctx context.Context) *profilerFilesDo {
	return p.profilerFilesDo.WithContext(ctx)
}

func (p profilerFiles) TableName() string { return p.profilerFilesDo.TableName() }

func (p profilerFiles) Alias() string { return p.profilerFilesDo.Alias() }

func (p profilerFiles) Columns(cols ...field.Expr) gen.Columns {
	return p.profilerFilesDo.Columns(cols...)
}

func (p *profilerFiles) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := p.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (p *profilerFiles) fillFieldMap() {
	p.fieldMap = make(map[string]field.Expr, 21)
	p.fieldMap["id"] = p.ID
	p.fieldMap["workload_uid"] = p.WorkloadUID
	p.fieldMap["pod_uid"] = p.PodUID
	p.fieldMap["pod_name"] = p.PodName
	p.fieldMap["pod_namespace"] = p.PodNamespace
	p.fieldMap["file_name"] = p.FileName
	p.fieldMap["file_path"] = p.FilePath
	p.fieldMap["file_type"] = p.FileType
	p.fieldMap["file_size"] = p.FileSize
	p.fieldMap["storage_type"] = p.StorageType
	p.fieldMap["storage_path"] = p.StoragePath
	p.fieldMap["storage_bucket"] = p.StorageBucket
	p.fieldMap["download_url"] = p.DownloadURL
	p.fieldMap["confidence"] = p.Confidence
	p.fieldMap["source_pid"] = p.SourcePid
	p.fieldMap["detected_at"] = p.DetectedAt
	p.fieldMap["collected_at"] = p.CollectedAt
	p.fieldMap["expires_at"] = p.ExpiresAt
	p.fieldMap["created_at"] = p.CreatedAt
	p.fieldMap["updated_at"] = p.UpdatedAt
	p.fieldMap["metadata"] = p.Metadata
}

func (p profilerFiles) clone(db *gorm.DB) profilerFiles {
	p.profilerFilesDo.ReplaceConnPool(db.Statement.ConnPool)
	return p
}

func (p profilerFiles) replaceDB(db *gorm.DB) profilerFiles {
	p.profilerFilesDo.ReplaceDB(db)
	return p
}

type profilerFilesDo struct{ gen.DO }

func (p profilerFilesDo) Debug() *profilerFilesDo {
	return p.withDO(p.DO.Debug())
}

func (p profilerFilesDo) WithContext(ctx context.Context) *profilerFilesDo {
	return p.withDO(p.DO.WithContext(ctx))
}

func (p profilerFilesDo) ReadDB() *profilerFilesDo {
	return p.Clauses(dbresolver.Read)
}

func (p profilerFilesDo) WriteDB() *profilerFilesDo {
	return p.Clauses(dbresolver.Write)
}

func (p profilerFilesDo) Session(config *gorm.Session) *profilerFilesDo {
	return p.withDO(p.DO.Session(config))
}

func (p profilerFilesDo) Clauses(conds ...clause.Expression) *profilerFilesDo {
	return p.withDO(p.DO.Clauses(conds...))
}

func (p profilerFilesDo) Returning(value interface{}, columns ...string) *profilerFilesDo {
	return p.withDO(p.DO.Returning(value, columns...))
}

func (p profilerFilesDo) Not(conds ...gen.Condition) *profilerFilesDo {
	return p.withDO(p.DO.Not(conds...))
}

func (p profilerFilesDo) Or(conds ...gen.Condition) *profilerFilesDo {
	return p.withDO(p.DO.Or(conds...))
}

func (p profilerFilesDo) Select(conds ...field.Expr) *profilerFilesDo {
	return p.withDO(p.DO.Select(conds...))
}

func (p profilerFilesDo) Where(conds ...gen.Condition) *profilerFilesDo {
	return p.withDO(p.DO.Where(conds...))
}

func (p profilerFilesDo) Order(conds ...field.Expr) *profilerFilesDo {
	return p.withDO(p.DO.Order(conds...))
}

func (p profilerFilesDo) Distinct(cols ...field.Expr) *profilerFilesDo {
	return p.withDO(p.DO.Distinct(cols...))
}

func (p profilerFilesDo) Omit(cols ...field.Expr) *profilerFilesDo {
	return p.withDO(p.DO.Omit(cols...))
}

func (p profilerFilesDo) Join(table schema.Tabler, on ...field.Expr) *profilerFilesDo {
	return p.withDO(p.DO.Join(table, on...))
}

func (p profilerFilesDo) LeftJoin(table schema.Tabler, on ...field.Expr) *profilerFilesDo {
	return p.withDO(p.DO.LeftJoin(table, on...))
}

func (p profilerFilesDo) RightJoin(table schema.Tabler, on ...field.Expr) *profilerFilesDo {
	return p.withDO(p.DO.RightJoin(table, on...))
}

func (p profilerFilesDo) Group(cols ...field.Expr) *profilerFilesDo {
	return p.withDO(p.DO.Group(cols...))
}

func (p profilerFilesDo) Having(conds ...gen.Condition) *profilerFilesDo {
	return p.withDO(p.DO.Having(conds...))
}

func (p profilerFilesDo) Limit(limit int) *profilerFilesDo {
	return p.withDO(p.DO.Limit(limit))
}

func (p profilerFilesDo) Offset(offset int) *profilerFilesDo {
	return p.withDO(p.DO.Offset(offset))
}

func (p profilerFilesDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *profilerFilesDo {
	return p.withDO(p.DO.Scopes(funcs...))
}

func (p profilerFilesDo) Unscoped() *profilerFilesDo {
	return p.withDO(p.DO.Unscoped())
}

func (p profilerFilesDo) Create(values ...*model.ProfilerFiles) error {
	if len(values) == 0 {
		return nil
	}
	return p.DO.Create(values)
}

func (p profilerFilesDo) CreateInBatches(values []*model.ProfilerFiles, batchSize int) error {
	return p.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (p profilerFilesDo) Save(values ...*model.ProfilerFiles) error {
	if len(values) == 0 {
		return nil
	}
	return p.DO.Save(values)
}

func (p profilerFilesDo) First() (*model.ProfilerFiles, error) {
	if result, err := p.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.ProfilerFiles), nil
	}
}

func (p profilerFilesDo) Take() (*model.ProfilerFiles, error) {
	if result, err := p.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.ProfilerFiles), nil
	}
}

func (p profilerFilesDo) Last() (*model.ProfilerFiles, error) {
	if result, err := p.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.ProfilerFiles), nil
	}
}

func (p profilerFilesDo) Find() ([]*model.ProfilerFiles, error) {
	result, err := p.DO.Find()
	return result.([]*model.ProfilerFiles), err
}

func (p profilerFilesDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ProfilerFiles, err error) {
	buf := make([]*model.ProfilerFiles, 0, batchSize)
	err = p.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (p profilerFilesDo) FindInBatches(result *[]*model.ProfilerFiles, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return p.DO.FindInBatches(result, batchSize, fc)
}

func (p profilerFilesDo) Attrs(attrs ...field.AssignExpr) *profilerFilesDo {
	return p.withDO(p.DO.Attrs(attrs...))
}

func (p profilerFilesDo) Assign(attrs ...field.AssignExpr) *profilerFilesDo {
	return p.withDO(p.DO.Assign(attrs...))
}

func (p profilerFilesDo) Joins(fields ...field.RelationField) *profilerFilesDo {
	for _, _f := range fields {
		p = *p.withDO(p.DO.Joins(_f))
	}
	return &p
}

func (p profilerFilesDo) Preload(fields ...field.RelationField) *profilerFilesDo {
	for _, _f := range fields {
		p = *p.withDO(p.DO.Preload(_f))
	}
	return &p
}

func (p profilerFilesDo) FirstOrInit() (*model.ProfilerFiles, error) {
	if result, err := p.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.ProfilerFiles), nil
	}
}

func (p profilerFilesDo) FirstOrCreate() (*model.ProfilerFiles, error) {
	if result, err := p.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.ProfilerFiles), nil
	}
}

func (p profilerFilesDo) FindByPage(offset int, limit int) (result []*model.ProfilerFiles, count int64, err error) {
	result, err = p.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = p.Offset(-1).Limit(-1).Count()
	return
}

func (p profilerFilesDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = p.Count()
	if err != nil {
		return
	}

	err = p.Offset(offset).Limit(limit).Scan(result)
	return
}

func (p profilerFilesDo) Scan(result interface{}) (err error) {
	return p.DO.Scan(result)
}

func (p profilerFilesDo) Delete(models ...*model.ProfilerFiles) (result gen.ResultInfo, err error) {
	return p.DO.Delete(models)
}

func (p *profilerFilesDo) withDO(do gen.Dao) *profilerFilesDo {
	p.DO = *do.(*gen.DO)
	return p
}
