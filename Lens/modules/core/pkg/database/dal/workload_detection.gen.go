// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dal

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/AMD-AGI/Primus-SaFE/Lens/core/pkg/database/model"
)

func newWorkloadDetection(db *gorm.DB, opts ...gen.DOOption) workloadDetection {
	_workloadDetection := workloadDetection{}

	_workloadDetection.workloadDetectionDo.UseDB(db, opts...)
	_workloadDetection.workloadDetectionDo.UseModel(&model.WorkloadDetection{})

	tableName := _workloadDetection.workloadDetectionDo.TableName()
	_workloadDetection.ALL = field.NewAsterisk(tableName)
	_workloadDetection.ID = field.NewInt64(tableName, "id")
	_workloadDetection.WorkloadUID = field.NewString(tableName, "workload_uid")
	_workloadDetection.Status = field.NewString(tableName, "status")
	_workloadDetection.Framework = field.NewString(tableName, "framework")
	_workloadDetection.Frameworks = field.NewField(tableName, "frameworks")
	_workloadDetection.WorkloadType = field.NewString(tableName, "workload_type")
	_workloadDetection.Confidence = field.NewFloat64(tableName, "confidence")
	_workloadDetection.FrameworkLayer = field.NewString(tableName, "framework_layer")
	_workloadDetection.WrapperFramework = field.NewString(tableName, "wrapper_framework")
	_workloadDetection.BaseFramework = field.NewString(tableName, "base_framework")
	_workloadDetection.DetectionState = field.NewString(tableName, "detection_state")
	_workloadDetection.AttemptCount = field.NewInt32(tableName, "attempt_count")
	_workloadDetection.MaxAttempts = field.NewInt32(tableName, "max_attempts")
	_workloadDetection.LastAttemptAt = field.NewTime(tableName, "last_attempt_at")
	_workloadDetection.NextAttemptAt = field.NewTime(tableName, "next_attempt_at")
	_workloadDetection.Context = field.NewField(tableName, "context")
	_workloadDetection.EvidenceCount = field.NewInt32(tableName, "evidence_count")
	_workloadDetection.EvidenceSources = field.NewField(tableName, "evidence_sources")
	_workloadDetection.Conflicts = field.NewField(tableName, "conflicts")
	_workloadDetection.CreatedAt = field.NewTime(tableName, "created_at")
	_workloadDetection.UpdatedAt = field.NewTime(tableName, "updated_at")
	_workloadDetection.ConfirmedAt = field.NewTime(tableName, "confirmed_at")

	_workloadDetection.fillFieldMap()

	return _workloadDetection
}

type workloadDetection struct {
	workloadDetectionDo workloadDetectionDo

	ALL              field.Asterisk
	ID               field.Int64
	WorkloadUID      field.String  // Workload unique identifier (unique)
	Status           field.String  // Detection status: unknown, suspected, confirmed, verified, conflict
	Framework        field.String  // Primary framework (aggregated result)
	Frameworks       field.Field   // All frameworks as JSON array (aggregated result)
	WorkloadType     field.String  // Workload type: training or inference
	Confidence       field.Float64 // Aggregated confidence score [0.000-1.000]
	FrameworkLayer   field.String  // Framework layer: wrapper or base
	WrapperFramework field.String  // Wrapper framework name
	BaseFramework    field.String  // Base framework name
	DetectionState   field.String  // Active detection task state: pending, in_progress, completed, failed
	AttemptCount     field.Int32   // Number of detection attempts made
	MaxAttempts      field.Int32   // Maximum detection attempts before giving up
	LastAttemptAt    field.Time    // Timestamp of last detection attempt
	NextAttemptAt    field.Time    // Scheduled time for next detection attempt
	Context          field.Field   // Detection context: retry config, probe settings, etc. (JSONB)
	EvidenceCount    field.Int32   // Total number of evidence records for this workload
	EvidenceSources  field.Field   // List of sources that contributed evidence (JSON array)
	Conflicts        field.Field   // Detection conflicts if any (JSON array)
	CreatedAt        field.Time
	UpdatedAt        field.Time
	ConfirmedAt      field.Time // Timestamp when detection was confirmed or verified

	fieldMap map[string]field.Expr
}

func (w workloadDetection) Table(newTableName string) *workloadDetection {
	w.workloadDetectionDo.UseTable(newTableName)
	return w.updateTableName(newTableName)
}

func (w workloadDetection) As(alias string) *workloadDetection {
	w.workloadDetectionDo.DO = *(w.workloadDetectionDo.As(alias).(*gen.DO))
	return w.updateTableName(alias)
}

func (w *workloadDetection) updateTableName(table string) *workloadDetection {
	w.ALL = field.NewAsterisk(table)
	w.ID = field.NewInt64(table, "id")
	w.WorkloadUID = field.NewString(table, "workload_uid")
	w.Status = field.NewString(table, "status")
	w.Framework = field.NewString(table, "framework")
	w.Frameworks = field.NewField(table, "frameworks")
	w.WorkloadType = field.NewString(table, "workload_type")
	w.Confidence = field.NewFloat64(table, "confidence")
	w.FrameworkLayer = field.NewString(table, "framework_layer")
	w.WrapperFramework = field.NewString(table, "wrapper_framework")
	w.BaseFramework = field.NewString(table, "base_framework")
	w.DetectionState = field.NewString(table, "detection_state")
	w.AttemptCount = field.NewInt32(table, "attempt_count")
	w.MaxAttempts = field.NewInt32(table, "max_attempts")
	w.LastAttemptAt = field.NewTime(table, "last_attempt_at")
	w.NextAttemptAt = field.NewTime(table, "next_attempt_at")
	w.Context = field.NewField(table, "context")
	w.EvidenceCount = field.NewInt32(table, "evidence_count")
	w.EvidenceSources = field.NewField(table, "evidence_sources")
	w.Conflicts = field.NewField(table, "conflicts")
	w.CreatedAt = field.NewTime(table, "created_at")
	w.UpdatedAt = field.NewTime(table, "updated_at")
	w.ConfirmedAt = field.NewTime(table, "confirmed_at")

	w.fillFieldMap()

	return w
}

func (w *workloadDetection) WithContext(ctx context.Context) *workloadDetectionDo {
	return w.workloadDetectionDo.WithContext(ctx)
}

func (w workloadDetection) TableName() string { return w.workloadDetectionDo.TableName() }

func (w workloadDetection) Alias() string { return w.workloadDetectionDo.Alias() }

func (w workloadDetection) Columns(cols ...field.Expr) gen.Columns {
	return w.workloadDetectionDo.Columns(cols...)
}

func (w *workloadDetection) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := w.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (w *workloadDetection) fillFieldMap() {
	w.fieldMap = make(map[string]field.Expr, 22)
	w.fieldMap["id"] = w.ID
	w.fieldMap["workload_uid"] = w.WorkloadUID
	w.fieldMap["status"] = w.Status
	w.fieldMap["framework"] = w.Framework
	w.fieldMap["frameworks"] = w.Frameworks
	w.fieldMap["workload_type"] = w.WorkloadType
	w.fieldMap["confidence"] = w.Confidence
	w.fieldMap["framework_layer"] = w.FrameworkLayer
	w.fieldMap["wrapper_framework"] = w.WrapperFramework
	w.fieldMap["base_framework"] = w.BaseFramework
	w.fieldMap["detection_state"] = w.DetectionState
	w.fieldMap["attempt_count"] = w.AttemptCount
	w.fieldMap["max_attempts"] = w.MaxAttempts
	w.fieldMap["last_attempt_at"] = w.LastAttemptAt
	w.fieldMap["next_attempt_at"] = w.NextAttemptAt
	w.fieldMap["context"] = w.Context
	w.fieldMap["evidence_count"] = w.EvidenceCount
	w.fieldMap["evidence_sources"] = w.EvidenceSources
	w.fieldMap["conflicts"] = w.Conflicts
	w.fieldMap["created_at"] = w.CreatedAt
	w.fieldMap["updated_at"] = w.UpdatedAt
	w.fieldMap["confirmed_at"] = w.ConfirmedAt
}

func (w workloadDetection) clone(db *gorm.DB) workloadDetection {
	w.workloadDetectionDo.ReplaceConnPool(db.Statement.ConnPool)
	return w
}

func (w workloadDetection) replaceDB(db *gorm.DB) workloadDetection {
	w.workloadDetectionDo.ReplaceDB(db)
	return w
}

type workloadDetectionDo struct{ gen.DO }

func (w workloadDetectionDo) Debug() *workloadDetectionDo {
	return w.withDO(w.DO.Debug())
}

func (w workloadDetectionDo) WithContext(ctx context.Context) *workloadDetectionDo {
	return w.withDO(w.DO.WithContext(ctx))
}

func (w workloadDetectionDo) ReadDB() *workloadDetectionDo {
	return w.Clauses(dbresolver.Read)
}

func (w workloadDetectionDo) WriteDB() *workloadDetectionDo {
	return w.Clauses(dbresolver.Write)
}

func (w workloadDetectionDo) Session(config *gorm.Session) *workloadDetectionDo {
	return w.withDO(w.DO.Session(config))
}

func (w workloadDetectionDo) Clauses(conds ...clause.Expression) *workloadDetectionDo {
	return w.withDO(w.DO.Clauses(conds...))
}

func (w workloadDetectionDo) Returning(value interface{}, columns ...string) *workloadDetectionDo {
	return w.withDO(w.DO.Returning(value, columns...))
}

func (w workloadDetectionDo) Not(conds ...gen.Condition) *workloadDetectionDo {
	return w.withDO(w.DO.Not(conds...))
}

func (w workloadDetectionDo) Or(conds ...gen.Condition) *workloadDetectionDo {
	return w.withDO(w.DO.Or(conds...))
}

func (w workloadDetectionDo) Select(conds ...field.Expr) *workloadDetectionDo {
	return w.withDO(w.DO.Select(conds...))
}

func (w workloadDetectionDo) Where(conds ...gen.Condition) *workloadDetectionDo {
	return w.withDO(w.DO.Where(conds...))
}

func (w workloadDetectionDo) Order(conds ...field.Expr) *workloadDetectionDo {
	return w.withDO(w.DO.Order(conds...))
}

func (w workloadDetectionDo) Distinct(cols ...field.Expr) *workloadDetectionDo {
	return w.withDO(w.DO.Distinct(cols...))
}

func (w workloadDetectionDo) Omit(cols ...field.Expr) *workloadDetectionDo {
	return w.withDO(w.DO.Omit(cols...))
}

func (w workloadDetectionDo) Join(table schema.Tabler, on ...field.Expr) *workloadDetectionDo {
	return w.withDO(w.DO.Join(table, on...))
}

func (w workloadDetectionDo) LeftJoin(table schema.Tabler, on ...field.Expr) *workloadDetectionDo {
	return w.withDO(w.DO.LeftJoin(table, on...))
}

func (w workloadDetectionDo) RightJoin(table schema.Tabler, on ...field.Expr) *workloadDetectionDo {
	return w.withDO(w.DO.RightJoin(table, on...))
}

func (w workloadDetectionDo) Group(cols ...field.Expr) *workloadDetectionDo {
	return w.withDO(w.DO.Group(cols...))
}

func (w workloadDetectionDo) Having(conds ...gen.Condition) *workloadDetectionDo {
	return w.withDO(w.DO.Having(conds...))
}

func (w workloadDetectionDo) Limit(limit int) *workloadDetectionDo {
	return w.withDO(w.DO.Limit(limit))
}

func (w workloadDetectionDo) Offset(offset int) *workloadDetectionDo {
	return w.withDO(w.DO.Offset(offset))
}

func (w workloadDetectionDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *workloadDetectionDo {
	return w.withDO(w.DO.Scopes(funcs...))
}

func (w workloadDetectionDo) Unscoped() *workloadDetectionDo {
	return w.withDO(w.DO.Unscoped())
}

func (w workloadDetectionDo) Create(values ...*model.WorkloadDetection) error {
	if len(values) == 0 {
		return nil
	}
	return w.DO.Create(values)
}

func (w workloadDetectionDo) CreateInBatches(values []*model.WorkloadDetection, batchSize int) error {
	return w.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (w workloadDetectionDo) Save(values ...*model.WorkloadDetection) error {
	if len(values) == 0 {
		return nil
	}
	return w.DO.Save(values)
}

func (w workloadDetectionDo) First() (*model.WorkloadDetection, error) {
	if result, err := w.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.WorkloadDetection), nil
	}
}

func (w workloadDetectionDo) Take() (*model.WorkloadDetection, error) {
	if result, err := w.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.WorkloadDetection), nil
	}
}

func (w workloadDetectionDo) Last() (*model.WorkloadDetection, error) {
	if result, err := w.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.WorkloadDetection), nil
	}
}

func (w workloadDetectionDo) Find() ([]*model.WorkloadDetection, error) {
	result, err := w.DO.Find()
	return result.([]*model.WorkloadDetection), err
}

func (w workloadDetectionDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.WorkloadDetection, err error) {
	buf := make([]*model.WorkloadDetection, 0, batchSize)
	err = w.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (w workloadDetectionDo) FindInBatches(result *[]*model.WorkloadDetection, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return w.DO.FindInBatches(result, batchSize, fc)
}

func (w workloadDetectionDo) Attrs(attrs ...field.AssignExpr) *workloadDetectionDo {
	return w.withDO(w.DO.Attrs(attrs...))
}

func (w workloadDetectionDo) Assign(attrs ...field.AssignExpr) *workloadDetectionDo {
	return w.withDO(w.DO.Assign(attrs...))
}

func (w workloadDetectionDo) Joins(fields ...field.RelationField) *workloadDetectionDo {
	for _, _f := range fields {
		w = *w.withDO(w.DO.Joins(_f))
	}
	return &w
}

func (w workloadDetectionDo) Preload(fields ...field.RelationField) *workloadDetectionDo {
	for _, _f := range fields {
		w = *w.withDO(w.DO.Preload(_f))
	}
	return &w
}

func (w workloadDetectionDo) FirstOrInit() (*model.WorkloadDetection, error) {
	if result, err := w.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.WorkloadDetection), nil
	}
}

func (w workloadDetectionDo) FirstOrCreate() (*model.WorkloadDetection, error) {
	if result, err := w.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.WorkloadDetection), nil
	}
}

func (w workloadDetectionDo) FindByPage(offset int, limit int) (result []*model.WorkloadDetection, count int64, err error) {
	result, err = w.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = w.Offset(-1).Limit(-1).Count()
	return
}

func (w workloadDetectionDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = w.Count()
	if err != nil {
		return
	}

	err = w.Offset(offset).Limit(limit).Scan(result)
	return
}

func (w workloadDetectionDo) Scan(result interface{}) (err error) {
	return w.DO.Scan(result)
}

func (w workloadDetectionDo) Delete(models ...*model.WorkloadDetection) (result gen.ResultInfo, err error) {
	return w.DO.Delete(models)
}

func (w *workloadDetectionDo) withDO(do gen.Dao) *workloadDetectionDo {
	w.DO = *do.(*gen.DO)
	return w
}
