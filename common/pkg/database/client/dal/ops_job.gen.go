// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dal

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/AMD-AIG-AIMA/SAFE/common/pkg/database/client/model"
)

func newOpsJob(db *gorm.DB, opts ...gen.DOOption) opsJob {
	_opsJob := opsJob{}

	_opsJob.opsJobDo.UseDB(db, opts...)
	_opsJob.opsJobDo.UseModel(&model.OpsJob{})

	tableName := _opsJob.opsJobDo.TableName()
	_opsJob.ALL = field.NewAsterisk(tableName)
	_opsJob.ID = field.NewInt32(tableName, "id")
	_opsJob.JobID = field.NewString(tableName, "job_id")
	_opsJob.Cluster = field.NewString(tableName, "cluster")
	_opsJob.Inputs = field.NewString(tableName, "inputs")
	_opsJob.Type = field.NewString(tableName, "type")
	_opsJob.Timeout = field.NewInt32(tableName, "timeout")
	_opsJob.UserName = field.NewString(tableName, "user_name")
	_opsJob.Workspace = field.NewString(tableName, "workspace")
	_opsJob.CreateTime = field.NewTime(tableName, "create_time")
	_opsJob.StartTime = field.NewTime(tableName, "start_time")
	_opsJob.EndTime = field.NewTime(tableName, "end_time")
	_opsJob.DeleteTime = field.NewTime(tableName, "delete_time")
	_opsJob.Phase = field.NewString(tableName, "phase")
	_opsJob.Conditions = field.NewString(tableName, "conditions")
	_opsJob.Outputs = field.NewString(tableName, "outputs")
	_opsJob.IsDeleted = field.NewBool(tableName, "is_deleted")
	_opsJob.Env = field.NewString(tableName, "env")
	_opsJob.UserID = field.NewString(tableName, "user_id")
	_opsJob.Resource = field.NewString(tableName, "resource")
	_opsJob.Image = field.NewString(tableName, "image")
	_opsJob.Entrypoint = field.NewString(tableName, "entrypoint")
	_opsJob.IsTolerateAll = field.NewBool(tableName, "is_tolerate_all")
	_opsJob.Hostpath = field.NewString(tableName, "hostpath")

	_opsJob.fillFieldMap()

	return _opsJob
}

type opsJob struct {
	opsJobDo opsJobDo

	ALL           field.Asterisk
	ID            field.Int32
	JobID         field.String
	Cluster       field.String
	Inputs        field.String
	Type          field.String
	Timeout       field.Int32
	UserName      field.String
	Workspace     field.String
	CreateTime    field.Time
	StartTime     field.Time
	EndTime       field.Time
	DeleteTime    field.Time
	Phase         field.String
	Conditions    field.String
	Outputs       field.String
	IsDeleted     field.Bool
	Env           field.String
	UserID        field.String
	Resource      field.String
	Image         field.String
	Entrypoint    field.String
	IsTolerateAll field.Bool
	Hostpath      field.String

	fieldMap map[string]field.Expr
}

func (o opsJob) Table(newTableName string) *opsJob {
	o.opsJobDo.UseTable(newTableName)
	return o.updateTableName(newTableName)
}

func (o opsJob) As(alias string) *opsJob {
	o.opsJobDo.DO = *(o.opsJobDo.As(alias).(*gen.DO))
	return o.updateTableName(alias)
}

func (o *opsJob) updateTableName(table string) *opsJob {
	o.ALL = field.NewAsterisk(table)
	o.ID = field.NewInt32(table, "id")
	o.JobID = field.NewString(table, "job_id")
	o.Cluster = field.NewString(table, "cluster")
	o.Inputs = field.NewString(table, "inputs")
	o.Type = field.NewString(table, "type")
	o.Timeout = field.NewInt32(table, "timeout")
	o.UserName = field.NewString(table, "user_name")
	o.Workspace = field.NewString(table, "workspace")
	o.CreateTime = field.NewTime(table, "create_time")
	o.StartTime = field.NewTime(table, "start_time")
	o.EndTime = field.NewTime(table, "end_time")
	o.DeleteTime = field.NewTime(table, "delete_time")
	o.Phase = field.NewString(table, "phase")
	o.Conditions = field.NewString(table, "conditions")
	o.Outputs = field.NewString(table, "outputs")
	o.IsDeleted = field.NewBool(table, "is_deleted")
	o.Env = field.NewString(table, "env")
	o.UserID = field.NewString(table, "user_id")
	o.Resource = field.NewString(table, "resource")
	o.Image = field.NewString(table, "image")
	o.Entrypoint = field.NewString(table, "entrypoint")
	o.IsTolerateAll = field.NewBool(table, "is_tolerate_all")
	o.Hostpath = field.NewString(table, "hostpath")

	o.fillFieldMap()

	return o
}

func (o *opsJob) WithContext(ctx context.Context) *opsJobDo { return o.opsJobDo.WithContext(ctx) }

func (o opsJob) TableName() string { return o.opsJobDo.TableName() }

func (o opsJob) Alias() string { return o.opsJobDo.Alias() }

func (o opsJob) Columns(cols ...field.Expr) gen.Columns { return o.opsJobDo.Columns(cols...) }

func (o *opsJob) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := o.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (o *opsJob) fillFieldMap() {
	o.fieldMap = make(map[string]field.Expr, 23)
	o.fieldMap["id"] = o.ID
	o.fieldMap["job_id"] = o.JobID
	o.fieldMap["cluster"] = o.Cluster
	o.fieldMap["inputs"] = o.Inputs
	o.fieldMap["type"] = o.Type
	o.fieldMap["timeout"] = o.Timeout
	o.fieldMap["user_name"] = o.UserName
	o.fieldMap["workspace"] = o.Workspace
	o.fieldMap["create_time"] = o.CreateTime
	o.fieldMap["start_time"] = o.StartTime
	o.fieldMap["end_time"] = o.EndTime
	o.fieldMap["delete_time"] = o.DeleteTime
	o.fieldMap["phase"] = o.Phase
	o.fieldMap["conditions"] = o.Conditions
	o.fieldMap["outputs"] = o.Outputs
	o.fieldMap["is_deleted"] = o.IsDeleted
	o.fieldMap["env"] = o.Env
	o.fieldMap["user_id"] = o.UserID
	o.fieldMap["resource"] = o.Resource
	o.fieldMap["image"] = o.Image
	o.fieldMap["entrypoint"] = o.Entrypoint
	o.fieldMap["is_tolerate_all"] = o.IsTolerateAll
	o.fieldMap["hostpath"] = o.Hostpath
}

func (o opsJob) clone(db *gorm.DB) opsJob {
	o.opsJobDo.ReplaceConnPool(db.Statement.ConnPool)
	return o
}

func (o opsJob) replaceDB(db *gorm.DB) opsJob {
	o.opsJobDo.ReplaceDB(db)
	return o
}

type opsJobDo struct{ gen.DO }

func (o opsJobDo) Debug() *opsJobDo {
	return o.withDO(o.DO.Debug())
}

func (o opsJobDo) WithContext(ctx context.Context) *opsJobDo {
	return o.withDO(o.DO.WithContext(ctx))
}

func (o opsJobDo) ReadDB() *opsJobDo {
	return o.Clauses(dbresolver.Read)
}

func (o opsJobDo) WriteDB() *opsJobDo {
	return o.Clauses(dbresolver.Write)
}

func (o opsJobDo) Session(config *gorm.Session) *opsJobDo {
	return o.withDO(o.DO.Session(config))
}

func (o opsJobDo) Clauses(conds ...clause.Expression) *opsJobDo {
	return o.withDO(o.DO.Clauses(conds...))
}

func (o opsJobDo) Returning(value interface{}, columns ...string) *opsJobDo {
	return o.withDO(o.DO.Returning(value, columns...))
}

func (o opsJobDo) Not(conds ...gen.Condition) *opsJobDo {
	return o.withDO(o.DO.Not(conds...))
}

func (o opsJobDo) Or(conds ...gen.Condition) *opsJobDo {
	return o.withDO(o.DO.Or(conds...))
}

func (o opsJobDo) Select(conds ...field.Expr) *opsJobDo {
	return o.withDO(o.DO.Select(conds...))
}

func (o opsJobDo) Where(conds ...gen.Condition) *opsJobDo {
	return o.withDO(o.DO.Where(conds...))
}

func (o opsJobDo) Order(conds ...field.Expr) *opsJobDo {
	return o.withDO(o.DO.Order(conds...))
}

func (o opsJobDo) Distinct(cols ...field.Expr) *opsJobDo {
	return o.withDO(o.DO.Distinct(cols...))
}

func (o opsJobDo) Omit(cols ...field.Expr) *opsJobDo {
	return o.withDO(o.DO.Omit(cols...))
}

func (o opsJobDo) Join(table schema.Tabler, on ...field.Expr) *opsJobDo {
	return o.withDO(o.DO.Join(table, on...))
}

func (o opsJobDo) LeftJoin(table schema.Tabler, on ...field.Expr) *opsJobDo {
	return o.withDO(o.DO.LeftJoin(table, on...))
}

func (o opsJobDo) RightJoin(table schema.Tabler, on ...field.Expr) *opsJobDo {
	return o.withDO(o.DO.RightJoin(table, on...))
}

func (o opsJobDo) Group(cols ...field.Expr) *opsJobDo {
	return o.withDO(o.DO.Group(cols...))
}

func (o opsJobDo) Having(conds ...gen.Condition) *opsJobDo {
	return o.withDO(o.DO.Having(conds...))
}

func (o opsJobDo) Limit(limit int) *opsJobDo {
	return o.withDO(o.DO.Limit(limit))
}

func (o opsJobDo) Offset(offset int) *opsJobDo {
	return o.withDO(o.DO.Offset(offset))
}

func (o opsJobDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *opsJobDo {
	return o.withDO(o.DO.Scopes(funcs...))
}

func (o opsJobDo) Unscoped() *opsJobDo {
	return o.withDO(o.DO.Unscoped())
}

func (o opsJobDo) Create(values ...*model.OpsJob) error {
	if len(values) == 0 {
		return nil
	}
	return o.DO.Create(values)
}

func (o opsJobDo) CreateInBatches(values []*model.OpsJob, batchSize int) error {
	return o.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (o opsJobDo) Save(values ...*model.OpsJob) error {
	if len(values) == 0 {
		return nil
	}
	return o.DO.Save(values)
}

func (o opsJobDo) First() (*model.OpsJob, error) {
	if result, err := o.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.OpsJob), nil
	}
}

func (o opsJobDo) Take() (*model.OpsJob, error) {
	if result, err := o.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.OpsJob), nil
	}
}

func (o opsJobDo) Last() (*model.OpsJob, error) {
	if result, err := o.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.OpsJob), nil
	}
}

func (o opsJobDo) Find() ([]*model.OpsJob, error) {
	result, err := o.DO.Find()
	return result.([]*model.OpsJob), err
}

func (o opsJobDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.OpsJob, err error) {
	buf := make([]*model.OpsJob, 0, batchSize)
	err = o.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (o opsJobDo) FindInBatches(result *[]*model.OpsJob, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return o.DO.FindInBatches(result, batchSize, fc)
}

func (o opsJobDo) Attrs(attrs ...field.AssignExpr) *opsJobDo {
	return o.withDO(o.DO.Attrs(attrs...))
}

func (o opsJobDo) Assign(attrs ...field.AssignExpr) *opsJobDo {
	return o.withDO(o.DO.Assign(attrs...))
}

func (o opsJobDo) Joins(fields ...field.RelationField) *opsJobDo {
	for _, _f := range fields {
		o = *o.withDO(o.DO.Joins(_f))
	}
	return &o
}

func (o opsJobDo) Preload(fields ...field.RelationField) *opsJobDo {
	for _, _f := range fields {
		o = *o.withDO(o.DO.Preload(_f))
	}
	return &o
}

func (o opsJobDo) FirstOrInit() (*model.OpsJob, error) {
	if result, err := o.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.OpsJob), nil
	}
}

func (o opsJobDo) FirstOrCreate() (*model.OpsJob, error) {
	if result, err := o.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.OpsJob), nil
	}
}

func (o opsJobDo) FindByPage(offset int, limit int) (result []*model.OpsJob, count int64, err error) {
	result, err = o.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = o.Offset(-1).Limit(-1).Count()
	return
}

func (o opsJobDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = o.Count()
	if err != nil {
		return
	}

	err = o.Offset(offset).Limit(limit).Scan(result)
	return
}

func (o opsJobDo) Scan(result interface{}) (err error) {
	return o.DO.Scan(result)
}

func (o opsJobDo) Delete(models ...*model.OpsJob) (result gen.ResultInfo, err error) {
	return o.DO.Delete(models)
}

func (o *opsJobDo) withDO(do gen.Dao) *opsJobDo {
	o.DO = *do.(*gen.DO)
	return o
}
